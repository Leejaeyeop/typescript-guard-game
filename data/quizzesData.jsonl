{"id":0,"difficultyLevel":"BEGINNER","category":"Interface and Property Access","explanation":"The 'email' property is not defined in the type of the 'user' object. A compile error occurs because of an attempt to access a non-existent property.","question":"const user: { name: string, age: number } = {\n  name: \"Alice\",\n  age: 30\n};\n\nconsole.log(user.email);","answer":false}
{"id":1,"difficultyLevel":"BEGINNER","category":"Union Types","explanation":"The 'id' variable is declared to accept either 'string' or 'number' types. Since values of both types can be assigned, no error occurs.","question":"let id: string | number = \"user-123\";\nid = 456;","answer":true}
{"id":2,"difficultyLevel":"BEGINNER","category":"Array Types","explanation":"The 'items' array is declared to only accept elements of type 'string'. A compile error occurs due to a type mismatch from attempting to add the number 123.","question":"let items: string[] = [\"Apple\", \"Banana\"];\nitems.push(123);","answer":false}
{"id":3,"difficultyLevel":"BEGINNER","category":"Function Basics","explanation":"The function expects an argument of type 'number', and a value of type 'number' was correctly passed during the call. No error occurs as the types match.","question":"function printScore(score: number): void {\n  console.log(`Score: ${score}`);\n}\n\nprintScore(100);","answer":true}
{"id":4,"difficultyLevel":"BEGINNER","category":"any Type","explanation":"The 'any' type disables all type checking. Therefore, even if a method named 'log' does not actually exist on the 'config' object, it will not cause a compile-time error. (However, a runtime error will occur upon execution.)","question":"const config: any = { setting: \"on\" };\nconfig.log();","answer":true}
{"id":5,"difficultyLevel":"BEGINNER","category":"Tuple Types","explanation":"Tuples are arrays with a fixed number of elements whose types are known. The 'person' variable is a tuple of type [string, number], and the assigned value's types and order match, so there is no error.","question":"let person: [string, number];\nperson = [\"John\", 42];","answer":true}
{"id":6,"difficultyLevel":"BEGINNER","category":"Readonly Properties","explanation":"The 'id' property is declared as 'readonly', so it cannot be reassigned after initialization. Attempting to reassign it causes a compile error.","question":"interface User {\n  readonly id: number;\n  name: string;\n}\n\nconst user: User = { id: 1, name: \"Admin\" };\nuser.id = 2;","answer":false}
{"id":7,"difficultyLevel":"BEGINNER","category":"Enums","explanation":"Declaring a variable with an Enum type and assigning a member of that Enum is correct usage. The types match, so there is no error.","question":"enum Direction {\n  Up,\n  Down,\n  Left,\n  Right\n}\n\nlet myDirection: Direction = Direction.Up;","answer":true}
{"id":8,"difficultyLevel":"BEGINNER","category":"unknown Type","explanation":"Unlike 'any', the 'unknown' type does not allow accessing properties or calling methods without first asserting or narrowing the type (using a type guard). A compile error occurs because no type check is performed.","question":"let value: unknown = \"Hello World\";\nconsole.log(value.length);","answer":false}
{"id":9,"difficultyLevel":"BEGINNER","category":"Optional Parameters and Nullish Coalescing","explanation":"The function's 'message' parameter is optional ('?'), so it can be called without an argument. Inside the function, the '??' operator safely handles the case where 'message' is undefined by providing a default value, so there is no error.","question":"function log(message?: string) {\n  console.log(message ?? \"No message provided\");\n}\n\nlog();","answer":true}
{"id":10,"difficultyLevel":"INTERMEDIATE","category":"Intersection Types","explanation":"An intersection type (&) combines multiple types into one. 'ElevatedEmployee' must have all properties of both 'Admin' and 'Employee'. The 'e1' object has all the required properties, so its type is correct.","question":"type Admin = { name: string; privileges: string[]; };\ntype Employee = { name: string; startDate: Date; };\n\ntype ElevatedEmployee = Admin & Employee;\n\nconst e1: ElevatedEmployee = {\n  name: \"Alice\",\n  privileges: [\"create-server\"],\n  startDate: new Date()\n};","answer":true}
{"id":11,"difficultyLevel":"INTERMEDIATE","category":"Function Inference without Generics","explanation":"Without generics, TypeScript infers the widest possible return type based on the input union type. Therefore, the return type becomes (string | number)[] instead of string[]. The code runs without error.","question":"function wrapInArray(obj: string | number) {\n  return [obj];\n}\n\nconst result = wrapInArray(\"hello\");","answer":true}
{"id":12,"difficultyLevel":"INTERMEDIATE","category":"Common Properties in Union Types","explanation":"A variable declared with a union type can only safely access properties that are common to all types in the union. 'layEggs' exists in both 'Bird' and 'Fish', so it can be called without error.","question":"interface Bird { fly(): void; layEggs(): void; }\ninterface Fish { swim(): void; layEggs(): void; }\n\nfunction getPet(): Bird | Fish {\n  \n  return { fly(){}, swim(){}, layEggs(){} } as Fish;\n}\n\nconst pet = getPet();\npet.layEggs();","answer":true}
{"id":13,"difficultyLevel":"INTERMEDIATE","category":"Classes and 'this' Context","explanation":"When a class method is assigned to a variable and then called, it loses its 'this' context. When 'greetFunction()' is called, 'this' becomes 'undefined', making it impossible to access 'this.greeting'. There is no compile error, but a runtime error occurs (in strict mode).","question":"class Greeter {\n  greeting: string;\n  constructor(message: string) { this.greeting = message; }\n\n  greet() { return \"Hello, \" + this.greeting; }\n}\n\nconst greeter = new Greeter(\"world\");\nconst greetFunction = greeter.greet;\nconsole.log(greetFunction());","answer":true}
{"id":14,"difficultyLevel":"INTERMEDIATE","category":"Utility Type: Pick","explanation":"'Pick<T, K>' creates a new type by picking a set of properties K from type T. 'UserAge' becomes the type { age: number }, and the 'userAge' object perfectly matches this type.","question":"type User = { name: string; age: number; };\n\ntype UserAge = Pick<User, \"age\">;\n\nconst userAge: UserAge = { age: 30 };","answer":true}
{"id":15,"difficultyLevel":"INTERMEDIATE","category":"Utility Type: Omit","explanation":"'Omit<T, K>' creates a new type by removing properties K from type T. The 'user' object conforms to the 'UserWithoutEmail' type, from which 'email' has been removed, so there is no error.","question":"type User = { name: string; age: number; email: string; };\n\ntype UserWithoutEmail = Omit<User, \"email\">;\n\nconst user: UserWithoutEmail = {\n  name: \"Bob\",\n  age: 40\n};","answer":true}
{"id":16,"difficultyLevel":"INTERMEDIATE","category":"Utility Types: Exclude vs Extract","explanation":"'Exclude' removes types from the first union that are included in the second. 'Extract' extracts types from the first union that also exist in the second. Both variables are assigned values that match their inferred types, so there is no error.","question":"type T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\ntype T1 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;\n\nconst val: T0 = \"b\";\nconst val2: T1 = \"a\";","answer":true}
{"id":17,"difficultyLevel":"INTERMEDIATE","category":"Type Guard: instanceof","explanation":"The 'instanceof' operator acts as a type guard to narrow a union type. Inside the if block, x is safely treated as type 'Date', and in the else block, it's treated as type 'string'. There is no error.","question":"function logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString());\n  } else {\n    console.log(x.toUpperCase());\n  }\n}","answer":true}
{"id":18,"difficultyLevel":"INTERMEDIATE","category":"Utility Type: Partial","explanation":"'Partial<User>' makes all properties optional. Therefore, inside the 'updateUser' function, 'user.name' can be 'undefined'. Calling '.toUpperCase()' on 'undefined' causes a runtime error, which is detected at compile time, resulting in a compile error.","question":"type User = { name: string; age: number; };\nfunction updateUser(user: Partial<User>) {\n  console.log(user.name.toUpperCase());\n}\n\nupdateUser({ age: 31 });","answer":false}
{"id":19,"difficultyLevel":"INTERMEDIATE","category":"Discriminated Unions","explanation":"The 'status' property acts as a discriminant to distinguish between types in the union. Inside the if (res.status === \"success\") block, the type of 'res' is narrowed to { status: \"success\"; data: any; }. This type does not have an 'error' property, so a compile error occurs.","question":"type ResponseData = { status: \"success\"; data: any; } | { status: \"error\"; error: Error; };\n\nfunction handleResponse(res: ResponseData) {\n  if (res.status === \"success\") {\n    console.log(res.error);\n  }\n}","answer":false}
{"id":20,"difficultyLevel":"EXPERT","category":"Nominal Typing (Branding)","explanation":"Type branding is a technique to treat types with the same underlying structure as nominally different. The 'getUser' function expects the branded 'UserID' type, but a plain 'string' was passed. The two types are not compatible, resulting in a compile error.","question":"type UserID = string & { readonly brand: unique symbol };\n\nfunction UserID(id: string): UserID {\n  return id as UserID;\n}\n\nfunction getUser(id: UserID) {\n  console.log(id);\n}\n\ngetUser(\"user-123\");","answer":false}
{"id":21,"difficultyLevel":"EXPERT","category":"Mapped Types","explanation":"A mapped type was used to define an object type where the keys are members of the 'Routes' union. The 'config' object satisfies all requirements of the 'RouteConfig' type, so there is no error.","question":"type Routes = \"/\" | \"/about\" | \"/contact\";\ntype RouteConfig = { [K in Routes]: { component: string } };\n\nconst config: RouteConfig = {\n  \"/\": { component: \"Home\" },\n  \"/about\": { component: \"About\" },\n  \"/contact\": { component: \"Contact\" }\n};","answer":true}
{"id":22,"difficultyLevel":"EXPERT","category":"Conditional Types and infer","explanation":"'UnpackPromise' uses a conditional type to 'infer' and return the inner type U if T is a Promise. Since 'ReturnType<typeof fetchData>' is 'Promise<string>', the type 'Data' becomes 'string'. 'myData' is of type 'string', so there is no error.","question":"type UnpackPromise<T> = T extends Promise<infer U> ? U : T;\n\nasync function fetchData() { return \"some data\"; }\n\ntype Data = UnpackPromise<ReturnType<typeof fetchData>>;\n\nconst myData: Data = \"hello\";","answer":true}
{"id":23,"difficultyLevel":"EXPERT","category":"Utility Type: NonNullable and never","explanation":"'NonNullable<T>' is a utility type that removes null and undefined from T. 'MustBeString' becomes type 'string'. Attempting to assign 'null' to a variable of type 'string' causes a compile error.","question":"type NonNullable<T> = T extends null | undefined ? never : T;\ntype MaybeString = string | null | undefined;\ntype MustBeString = NonNullable<MaybeString>;\n\nconst str: MustBeString = null;","answer":false}
{"id":24,"difficultyLevel":"EXPERT","category":"satisfies Operator","explanation":"The 'satisfies' operator checks if an expression conforms to a certain type while preserving the expression's own specific type. The 'user' object satisfies the 'User' type (email is optional) and simultaneously has the specific type {id, name, role}. Therefore, accessing 'user.role' is possible and causes no error.","question":"type User = {\n  id: number;\n  name: string;\n  email?: string;\n}\n\nconst user = {\n  id: 1,\n  name: \"Alice\",\n  role: \"admin\" \n} satisfies User;\n\nconsole.log(user.role);","answer":true}
{"id":25,"difficultyLevel":"EXPERT","category":"Mapped and Conditional Types","explanation":"The 'Person' type resolves to { name: string; age: number; }. The 'p' object is missing the required 'name' property, which causes a compile error.","question":"type Keys = \"name\" | \"age\";\n\ntype Person = { [K in Keys]: K extends \"name\" ? string : number };\n\nconst p: Person = { age: 30 };","answer":false}
{"id":26,"difficultyLevel":"EXPERT","category":"Variadic Tuple Types","explanation":"The '...' syntax can be used in tuple types to represent tuples of variable length. The 'combine' function takes two arrays/tuples and returns a new tuple type with a precise type sequence. Type inference works correctly, so there is no error.","question":"function combine<T extends any[], U extends any[]>(arr1: T, arr2: U): [...T, ...U] {\n  return [...arr1, ...arr2];\n}\n\nconst combined = combine([1, 2], [\"a\", \"b\"]);\n\nconst first = combined[0]; \nconst third = combined[2];","answer":true}
{"id":27,"difficultyLevel":"EXPERT","category":"Key Remapping in Mapped Types","explanation":"The 'as' clause in a mapped type can be used to rename property keys. 'CircleGetters' becomes the type { getRadius: () => number; getColor: () => string; }. The 'circleGetters' object perfectly implements this type, so there is no error.","question":"type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\n\ninterface Circle { radius: number; color: string; }\ntype CircleGetters = Getters<Circle>;\n\nconst circleGetters: CircleGetters = {\n  getRadius: () => 10,\n  getColor: () => \"red\"\n};","answer":true}
{"id":28,"difficultyLevel":"EXPERT","category":"Distributive Conditional Types","explanation":"When the generic in a conditional type is a union type, it is applied to each member of the union individually, and the results are unioned back together (distributive behavior). Therefore, 'StrOrNumArray' becomes 'string[] | number[]'. This type means 'an array of only strings' or 'an array of only numbers', so an array containing a mix of both types cannot be assigned, causing a compile error.","question":"type ToArray<T> = T extends any ? T[] : never;\n\ntype StrOrNumArray = ToArray<string | number>;\n\nconst arr: StrOrNumArray = [\"hello\", 1];","answer":false}
{"id":29,"difficultyLevel":"EXPERT","category":"Discriminated Unions and Type Narrowing","explanation":"The 'kind' property is used to narrow the type. Inside the if block, the type of 'obj' is confirmed to be 'A'. Since type 'A' does not have a 'b' property, attempting to access 'obj.b' causes a compile error.","question":"type A = { kind: 'a', a: string };\ntype B = { kind: 'b', b: string };\n\nfunction process(obj: A | B) {\n  \n  if (obj.kind === 'a') {\n    console.log(obj.b);\n  }\n}","answer":false}
{"id":30,"difficultyLevel":"BEGINNER","category":"Type Assertion","explanation":"The value of type 'any' was asserted as 'string' using the 'as' keyword. TypeScript trusts the developer's assertion, so no compile-time error occurs. Since the value is actually a string, there is no runtime error either.","question":"let value: any = 'this is a string';\nlet len: number = (value as string).length;","answer":true}
{"id":31,"difficultyLevel":"BEGINNER","category":"Function Return Type: never","explanation":"The 'never' type indicates that a function never returns. It's used for functions that always throw an exception or enter an infinite loop. This function always throws an exception, so the 'never' type is used correctly.","question":"function throwError(message: string): never {\n  throw new Error(message);\n}","answer":true}
{"id":32,"difficultyLevel":"BEGINNER","category":"Object Literal Type Inference","explanation":"The variable 'user' is inferred to have the type { name: string; age: number; }. The 'age' property is of type 'number', so attempting to assign a 'string' value to it causes a compile error.","question":"let user = { name: 'John', age: 30 };\nuser.age = 'thirty';","answer":false}
{"id":33,"difficultyLevel":"BEGINNER","category":"void Return Type","explanation":"'void' indicates that a function does not explicitly return anything. The 'logMessage' function does not return a value, so specifying its return type as 'void' is correct.","question":"function logMessage(message: string): void {\n  console.log(message);\n}","answer":true}
{"id":34,"difficultyLevel":"BEGINNER","category":"Type Alias","explanation":"A type alias was used to define the type 'StringOrNumber' as 'string | number'. The 'id' variable is assigned values that conform to this type, so there is no error.","question":"type StringOrNumber = string | number;\nlet id: StringOrNumber = 'ID-001';\nid = 12345;","answer":true}
{"id":35,"difficultyLevel":"BEGINNER","category":"null vs undefined","explanation":"'null' is an intentional absence of any object value, while 'undefined' means a variable has not been assigned a value. You cannot assign 'null' to a variable of type 'string', resulting in a compile error (assuming the `strictNullChecks` option is enabled).","question":"let name: string = 'Alice';\nname = null;","answer":false}
{"id":36,"difficultyLevel":"BEGINNER","category":"Template Literal Types","explanation":"Template literals can be used to create types that specify the format of a string. The 'userId' variable conforms to the type of a string that starts with 'user_' and ends with a number, so there is no error.","question":"type UserID = `user_${number}`;\nlet userId: UserID = 'user_123';","answer":true}
{"id":37,"difficultyLevel":"BEGINNER","category":"Function Overloading","explanation":"Function overloading allows you to declare that a single function can accept arguments of different types. However, a compile error occurs because the argument `[1, 2, 3]` does not match any of the overload signatures.","question":"function double(x: string): string;\nfunction double(x: number): number;\nfunction double(x: any) { \n  if (typeof x === 'string') return x + x;\n  if (typeof x === 'number') return x * 2;\n}\ndouble([1, 2, 3]);","answer":false}
{"id":38,"difficultyLevel":"BEGINNER","category":"Interface Extension","explanation":"The 'Admin' interface extends the 'User' interface. Therefore, an object of type 'Admin' must have all properties from both 'User' and 'Admin'. 'adminUser' is missing the 'role' property, so an error occurs.","question":"interface User { id: number; }\ninterface Admin extends User { role: string; }\nconst adminUser: Admin = { id: 1 };","answer":false}
{"id":39,"difficultyLevel":"BEGINNER","category":"Index Signatures","explanation":"Index signatures can define that an object can have arbitrary keys with values of a specific type. A compile error occurs because a 'string' is assigned to the 'Jane' property of the 'ages' object, which expects a 'number' type.","question":"const ages: { [index: string]: number } = {};\nages.John = 30;\nages.Jane = 'twenty-five';","answer":false}
{"id":40,"difficultyLevel":"INTERMEDIATE","category":"Type Guard: is","explanation":"This is a user-defined type guard function using the 'is' keyword. If the 'isString' function returns true, the type of 'foo' is narrowed to 'string' within the if block. Therefore, its '.length' property can be safely accessed.","question":"function isString(test: any): test is string {\n  return typeof test === 'string';\n}\n\nlet foo: unknown = 'hello';\nif (isString(foo)) {\n  console.log(foo.length);\n}","answer":true}
{"id":41,"difficultyLevel":"INTERMEDIATE","category":"Utility Type: Record","explanation":"'Record<K, T>' creates an object type with keys of type K and values of type T. 'PageInfo' represents an object where keys are one of 'home', 'about', 'contact', and values are { title: string }. The 'pages' object does not conform to this type because the value of the 'contact' property is incorrect, resulting in a compile error.","question":"type Page = 'home' | 'about' | 'contact';\ntype PageInfo = Record<Page, { title: string }>;\n\nconst pages: PageInfo = {\n  home: { title: 'Home' },\n  about: { title: 'About' },\n  contact: { title: 123 }\n};","answer":false}
{"id":42,"difficultyLevel":"INTERMEDIATE","category":"Generics with Defaults","explanation":"Default values can be specified for generic types. If no type is specified when calling the 'create' function, the default value 'boolean' is used. 'create()' returns an array of type 'boolean[]', so there is no error.","question":"function create<T = boolean>(): T[] {\n  return [];\n}\nconst bools = create();","answer":true}
{"id":43,"difficultyLevel":"INTERMEDIATE","category":"Abstract Classes","explanation":"Abstract classes cannot be instantiated directly. They can only be used through inheritance. 'new Department()' attempts to create an instance of an abstract class directly, which results in a compile error.","question":"abstract class Department {\n  constructor(public name: string) {}\n  abstract getInfo(): void;\n}\n\nconst accounting = new Department('Accounting');","answer":false}
{"id":44,"difficultyLevel":"INTERMEDIATE","category":"Utility Type: Required","explanation":"'Required<T>' makes all properties of T mandatory. Although 'c' in 'Props' was optional, it becomes required in 'RequiredProps'. The 'props' object is missing the required property 'c', resulting in a compile error.","question":"interface Props {\n  a?: number;\n  b?: string;\n  c?: boolean;\n}\n\ntype RequiredProps = Required<Props>;\nconst props: RequiredProps = { a: 1, b: 'test' };","answer":false}
{"id":45,"difficultyLevel":"INTERMEDIATE","category":"Type Guard: in","explanation":"The 'in' operator is a type guard that narrows a type by checking for the existence of a specific property on an object. Inside the if block, 'pet' is considered to be of type 'Fish', so calling '.swim()' is valid.","question":"interface Bird { fly(): void; }\ninterface Fish { swim(): void; }\n\nfunction move(pet: Bird | Fish) {\n  if ('swim' in pet) {\n    return pet.swim();\n  }\n  return pet.fly();\n}","answer":true}
{"id":46,"difficultyLevel":"INTERMEDIATE","category":"Class Property Initialization","explanation":"Class properties must be initialized either at the point of declaration or within the constructor. The 'name' property is not initialized, which causes a compile error (assuming the `strictPropertyInitialization` option is enabled).","question":"class Player {\n  name: string;\n  score: number = 0;\n}","answer":false}
{"id":47,"difficultyLevel":"INTERMEDIATE","category":"Generic Constraints","explanation":"The generic type 'T' is constrained to types that have a 'length' property. The passed object has a 'length' property, thus satisfying the constraint.","question":"interface Lengthy { length: number; }\n\nfunction countAndDescribe<T extends Lengthy>(element: T): [T, string] {\n  let description = 'Got no value.';\n  if (element.length > 0) {\n    description = 'Got ' + element.length + ' elements.';\n  }\n  return [element, description];\n}\n\ncountAndDescribe({ length: 10, value: 3 });","answer":true}
{"id":48,"difficultyLevel":"INTERMEDIATE","category":"Iterables and Generators","explanation":"A generator function returns an iterator object when called. The iterator's 'next()' method returns an object of the form { value, done }. 'gen.next().value' is 1, so the type is correct.","question":"function* numbers() {\n  yield 1;\n  yield 2;\n  return 3;\n}\nconst gen = numbers();\nconst val: number = gen.next().value;","answer":true}
{"id":49,"difficultyLevel":"INTERMEDIATE","category":"this parameters","explanation":"The callback function type for 'addClickListener' is specified with 'this: void', indicating that it does not use a 'this' context. The provided callback satisfies this requirement, so there is no error.","question":"interface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void;\n}\n\nclass Button implements UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void {}\n}\n\nconst button = new Button();\nbutton.addClickListener(function(e) {\n  console.log('clicked');\n});","answer":true}
{"id":50,"difficultyLevel":"EXPERT","category":"const Assertions","explanation":"'as const' makes TypeScript infer the narrowest possible type for a literal. 'routes' becomes type 'readonly [\"/\", \"/about\"]', and since 'req.path' is of type 'string', you cannot use 'includes' on the 'routes' array because 'routes' is not of type string[].","question":"const routes = [\"/\", \"/about\"] as const;\ntype Routes = typeof routes[number];\n\nfunction handleRequest(path: string) {\n  if (routes.includes(path)) { \n    // ...\n  }\n}","answer":false}
{"id":51,"difficultyLevel":"EXPERT","category":"Recursive Type Aliases","explanation":"Type aliases can refer to themselves to express recursive data structures. The 'Json' type represents a string, number, boolean, null, or an array or object containing itself as values. The 'data' object conforms to this structure.","question":"type Json = | string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst data: Json = {\n  name: \"data\",\n  items: [1, \"two\", { nested: true }]\n};","answer":true}
{"id":52,"difficultyLevel":"EXPERT","category":"Template Literals with infer","explanation":"Template literal types combined with 'infer' can be used to extract parts of a string and transform types. 'Getters' generates 'getName' and 'getAge' based on the keys of 'Person'. The 'personGetters' object satisfies all requirements of this type.","question":"type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n}\n\ninterface Person { name: string; age: number; }\ntype PersonGetters = Getters<Person>;\n\nconst personGetters: PersonGetters = {\n    getName: () => 'John',\n    getAge: () => 30\n};","answer":true}
{"id":53,"difficultyLevel":"EXPERT","category":"Covariance and Contravariance (Function Types)","explanation":"Function parameters are contravariant. This means a function that accepts a wider type (Animal) cannot be assigned to a function that expects a narrower type (Dog). Therefore, assigning 'logAnimal' to 'logDog' causes a compile error.","question":"class Animal {}\nclass Dog extends Animal {}\n\nlet logDog: (d: Dog) => void = (d) => {};\nlet logAnimal: (a: Animal) => void = (a) => {};\n\nlogDog = logAnimal;","answer":false}
{"id":54,"difficultyLevel":"EXPERT","category":"infer with Function Parameters","explanation":"'infer' can be used to extract the type of a function's parameters. The 'Params' type is resolved to 'string', which is the type of the first parameter of 'myFunc'. 'p' is of type 'string', so there is no error.","question":"type Params<F> = F extends (arg: infer P) => any ? P : never;\n\nconst myFunc = (name: string) => {};\ntype MyFuncParams = Params<typeof myFunc>;\n\nconst p: MyFuncParams = 'test';","answer":true}
{"id":55,"difficultyLevel":"EXPERT","category":"infer with Tuples","explanation":"The 'Tail' type extracts the remaining part of a tuple after the first element. The 'Tail' of 'MyTuple' becomes '[string, boolean]'. The 'rest' variable conforms to this type, so there is no error.","question":"type Tail<T extends any[]> = T extends [any, ...infer R] ? R : [];\n\ntype MyTuple = [number, string, boolean];\ntype MyTupleTail = Tail<MyTuple>;\n\nconst rest: MyTupleTail = ['a', true];","answer":true}
{"id":56,"difficultyLevel":"EXPERT","category":"Indexed Access Types","explanation":"Indexed access types can be used to look up the type of a property on another type. 'Person['addresses']' is of type 'Address[]', and 'AddressType' becomes 'Address'. The 'address' object does not conform to the 'Address' type because 'zipCode' is a string, resulting in a compile error.","question":"interface Address { street: string; zipCode: number; }\ninterface Person { addresses: Address[]; }\n\ntype AddressType = Person['addresses'][number];\nconst address: AddressType = { street: '123 Main St', zipCode: '12345' };","answer":false}
{"id":57,"difficultyLevel":"EXPERT","category":"const and Generic Functions","explanation":"Using 'as const' makes all properties of an object 'readonly' and infers values as literal types. 'makePair' returns 'readonly [T, U]', so 'pair' has the type 'readonly [string, number]'. Reassignment like 'pair[0] = ...' is not possible, causing a compile error.","question":"function makePair<T, U>(x: T, y: U) {\n  return [x, y] as const;\n}\n\nconst pair = makePair('hello', 42);\npair[0] = 'world';","answer":false}
{"id":58,"difficultyLevel":"EXPERT","category":"this Types and Type Guards","explanation":"'this is Date' is a type guard that asserts the object on which 'isDate' is called is of type 'Date'. Inside the if block, 'this' is treated as a 'Date'. Since it's called with the correct 'this' context via 'bind', there is no error.","question":"function isDate(this: any): this is Date {\n  return this instanceof Date;\n}\n\nconst maybeDate: unknown = new Date();\nif (isDate.call(maybeDate)) {\n  console.log(maybeDate.getTime());\n}","answer":true}
{"id":59,"difficultyLevel":"EXPERT","category":"Conditional Type Chaining","explanation":"'DeepReadonly' recursively makes all properties of an object 'readonly'. Since the 'config' object is of type 'DeepReadonly', properties of nested objects (like 'config.settings.theme') also cannot be reassigned, resulting in a compile error.","question":"type DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\nconst config = {\n  settings: { theme: 'dark' }\n};\n\nconst readonlyConfig: DeepReadonly<typeof config> = config;\nreadonlyConfig.settings.theme = 'light';","answer":false}
{"id":60,"difficultyLevel":"BEGINNER","category":"Literal Types","explanation":"The 'Status' type only allows the string literals 'success' or 'failure'. A compile error occurs because an unallowed string 'pending' is being assigned to the variable 'currentStatus'.","question":"type Status = 'success' | 'failure';\nlet currentStatus: Status = 'pending';","answer":false}
{"id":61,"difficultyLevel":"BEGINNER","category":"const and Object Properties","explanation":"An object declared with 'const' cannot be reassigned, but its internal properties can be modified. Modifying the 'user.name' property is a valid operation.","question":"const user = { name: 'Alice' };\nuser.name = 'Bob';","answer":true}
{"id":62,"difficultyLevel":"BEGINNER","category":"Risks of Type Assertion","explanation":"Type assertion forces the compiler to ignore type checking. 'value' is actually a number but is asserted as a 'string'. There is no compile error, but a runtime error will occur because there is no '.toUpperCase()' method on a number.","question":"const value: unknown = 123;\nconsole.log((value as string).toUpperCase());","answer":true}
{"id":63,"difficultyLevel":"BEGINNER","category":"String Enums","explanation":"Members of a string enum must be initialized at declaration. All members of 'LogLevel' are correctly initialized with string literals, so there is no error.","question":"enum LogLevel {\n  ERROR = 'ERROR',\n  WARN = 'WARN',\n  INFO = 'INFO'\n}\nconst level: LogLevel = LogLevel.INFO;","answer":true}
{"id":64,"difficultyLevel":"BEGINNER","category":"Union Types with null","explanation":"A variable declared with the union type 'string | null' can be assigned either a 'string' value or 'null'. Both assignments are valid, so there is no error.","question":"let name: string | null = 'Alice';\nname = null;","answer":true}
{"id":65,"difficultyLevel":"INTERMEDIATE","category":"ReadonlyArray<T>","explanation":"'ReadonlyArray<T>' represents a read-only array. This array type does not have methods that modify the array, such as 'push' or 'pop'. Attempting to call 'push' results in a compile error.","question":"const numbers: ReadonlyArray<number> = [1, 2, 3];\nnumbers.push(4);","answer":false}
{"id":66,"difficultyLevel":"INTERMEDIATE","category":"keyof typeof","explanation":"'typeof' gets the type of a value, and 'keyof' gets the keys of a type as a union. 'LogLevel' is an enum object, and 'keyof typeof LogLevel' becomes '\"ERROR\" | \"WARN\" | \"INFO\"'. 'levelKey' conforms to this type.","question":"enum LogLevel { ERROR, WARN, INFO }\ntype LogLevelStrings = keyof typeof LogLevel;\nconst levelKey: LogLevelStrings = 'WARN';","answer":true}
{"id":67,"difficultyLevel":"INTERMEDIATE","category":"Class Inheritance and Method Overriding","explanation":"A child class can override methods of its parent class. The 'Dog' class correctly overrides the 'move' method of 'Animal' and calls the parent method using 'super.move()'. There is no error.","question":"class Animal {\n  move(distance: number = 0) {\n    console.log(`Moved ${distance}m.`);\n  }\n}\nclass Dog extends Animal {\n  move(distance: number = 5) {\n    super.move(distance);\n  }\n}\nconst dog = new Dog();\ndog.move();","answer":true}
{"id":68,"difficultyLevel":"INTERMEDIATE","category":"private vs protected","explanation":"'protected' members are accessible only within the class and its subclasses. Since the 'Dog' class inherits from 'Animal', it can access 'this.name'. However, it is not accessible from instances outside the class, so 'dog.name' causes a compile error.","question":"class Animal {\n  protected name: string;\n  constructor(name: string) { this.name = name; }\n}\nclass Dog extends Animal {\n  getName() { return this.name; }\n}\nconst dog = new Dog('Max');\nconsole.log(dog.name);","answer":false}
{"id":69,"difficultyLevel":"INTERMEDIATE","category":"Optional Chaining with Functions","explanation":"Optional chaining (?.) prevents an error from being thrown when a property of an object is null or undefined, returning undefined instead. Since 'user.sayHi' does not exist, 'user.sayHi?.()' returns undefined without an error.","question":"type User = { name: string, sayHi?: () => void };\nconst user: User = { name: 'Alice' };\nuser.sayHi?.();","answer":true}
{"id":70,"difficultyLevel":"EXPERT","category":"Conditional Types with never","explanation":"The 'IsFunction' type returns 'never' if T is not a function. 'FunctionKeys' retains only the keys of properties in the 'Person' type that are function types. The 'key' variable becomes of type '\"sayHello\"', matching the assigned value.","question":"type IsFunction<T> = T extends (...args: any[]) => any ? T : never;\ntype FunctionKeys<T> = { [K in keyof T]: IsFunction<T[K]> extends never ? never : K }[keyof T];\n\ninterface Person { name: string; age: number; sayHello(): void; }\ntype PersonFunctionKeys = FunctionKeys<Person>;\n\nconst key: PersonFunctionKeys = 'sayHello';","answer":true}
{"id":71,"difficultyLevel":"EXPERT","category":"Awaited<T> Utility Type","explanation":"The 'Awaited<T>' type recursively unwraps nested Promises to return the type of the finally resolved value. Since 'DeepPromise' is 'Promise<Promise<string>>', 'Awaited<DeepPromise>' becomes 'string'. The 'result' variable is of type 'string', so there is no error.","question":"type DeepPromise = Promise<Promise<string>>;\ntype Unwrapped = Awaited<DeepPromise>;\n\nconst result: Unwrapped = 'done';","answer":true}
{"id":72,"difficultyLevel":"EXPERT","category":"Constructor Functions and InstanceType<T>","explanation":"'InstanceType<T>' extracts the instance type of a constructor function. The instance type of the 'Car' class is '{ drive: () => void; }'. The 'factory' function should return an instance of this type, but it returns an object without the 'drive' method, causing a compile error.","question":"class Car {\n  drive() { console.log('vroom'); }\n}\n\nfunction factory<T extends new (...args: any[]) => any>(Ctor: T): InstanceType<T> {\n  return new Ctor();\n}\n\nconst myCar = factory(Car);\nmyCar.drive();","answer":true}
{"id":73,"difficultyLevel":"EXPERT","category":"Higher-Order Functions with Generics","explanation":"The 'withLogging' function uses generics to accept any function and returns a new function with added logging capabilities. Type inference works correctly, making 'loggedAdd' of type '(a: number, b: number) => number'. The types match upon calling.","question":"function withLogging<T extends (...args: any[]) => any>(fn: T): T {\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    console.log(`Calling ${fn.name}`);\n    return fn(...args);\n  }) as T;\n}\n\nconst add = (a: number, b: number) => a + b;\nconst loggedAdd = withLogging(add);\nloggedAdd(2, 3);","answer":true}
{"id":74,"difficultyLevel":"EXPERT","category":"Covariance and Contravariance (Objects)","explanation":"Object properties are covariant. An object with a narrower type property ('Dog') can be assigned to a place expecting an object with a wider type property ('Animal'). Assigning 'dogContainer' to 'animalContainer' is valid.","question":"class Animal {}\nclass Dog extends Animal {}\n\nlet animalContainer: { value: Animal } = { value: new Animal() };\nlet dogContainer: { value: Dog } = { value: new Dog() };\n\nanimalContainer = dogContainer;","answer":true}
{"id":75,"difficultyLevel":"EXPERT","category":"Mapped Types with Key Filtering","explanation":"Keys of a mapped type can be filtered using the 'as' clause and 'never'. 'PublicProps' retains only the keys from 'User' where the 'public' property is true ('name'). The 'publicUser' object should only have the 'name' property but includes 'age', causing a compile error.","question":"type User = {\n  name: { value: string; public: true };\n  age: { value: number; public: false };\n}\n\ntype PublicKeys<T> = { [K in keyof T]: T[K] extends { public: true } ? K : never }[keyof T];\ntype PublicProps = Pick<User, PublicKeys<User>>;\n\nconst publicUser: PublicProps = { name: { value: 'John', public: true }, age: { value: 30, public: false } };","answer":false}
{"id":76,"difficultyLevel":"EXPERT","category":"Mapped Types and `keyof`","explanation":"This code defines a `KeyMirror` type that transforms the type of each value in an object to the literal type of its key. `ActionTypes` becomes the type `{ login: \"login\"; logout: \"logout\"; }`. The type of the `action` variable conforms to this structure.","question":"type KeyMirror<T extends object> = { [K in keyof T]: K };\n\nconst actions = { login: null, logout: null };\ntype ActionTypes = KeyMirror<typeof actions>;\n\nconst action: ActionTypes = {\n  login: 'login',\n  logout: 'logout'\n};","answer":true}
{"id":77,"difficultyLevel":"EXPERT","category":"infer with Recursive Types","explanation":"The 'Flatten' type recursively unwraps one level of array nesting. When applied to `number[][][]`, it becomes `number[][]`. `flat1` conforms to this type.","question":"type Flatten<T> = T extends (infer U)[] ? U : T;\n\ntype N3 = number[][][];\ntype N2 = Flatten<N3>;\n\nconst flat1: N2 = [[1], [2]];","answer":true}
{"id":78,"difficultyLevel":"EXPERT","category":"Preventing Union Distribution","explanation":"Wrapping a generic type in a tuple, like `[T]`, within a conditional type prevents the distributive behavior of union types. `[T] extends [any]` is always true, so `ToArrayNonDist<string | number>` becomes `(string | number)[]`. The `arr` variable conforms to this type.","question":"type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;\n\ntype StrOrNumArray = ToArrayNonDist<string | number>;\n\nconst arr: StrOrNumArray = ['hello', 1];","answer":true}
{"id":79,"difficultyLevel":"EXPERT","category":"Decorators (Experimental)","explanation":"Decorators are an experimental feature for attaching additional functionality to classes, methods, and properties. The 'sealed' decorator freezes the class constructor and its prototype. The code is a valid example of decorator usage.","question":"function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n\n@sealed\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n}","answer":true}