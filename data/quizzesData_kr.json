[
  {
    "id": 0,
    "difficultyLevel": "BEGINNER",
    "category": "인터페이스와 프로퍼티 접근",
    "category_en": "Interface and Property Access",
    "explanation": "'user' 객체의 타입에는 'email' 프로퍼티가 정의되어 있지 않습니다. 존재하지 않는 프로퍼티에 접근하려고 시도했기 때문에 컴파일 에러가 발생합니다.",
    "explanation_en": "The 'email' property is not defined in the type of the 'user' object. A compile error occurs because of an attempt to access a non-existent property.",
    "question": "const user: { name: string, age: number } = {\n  name: \"Alice\",\n  age: 30\n};\n\nconsole.log(user.email);",
    "answer": false
  },
  {
    "id": 1,
    "difficultyLevel": "BEGINNER",
    "category": "유니언 타입 (Union Types)",
    "category_en": "Union Types",
    "explanation": "'id' 변수는 'string' 또는 'number' 타입을 가질 수 있도록 선언되었습니다. 두 타입의 값 모두 할당이 가능하므로 에러가 발생하지 않습니다.",
    "explanation_en": "The 'id' variable is declared to accept either 'string' or 'number' types. Since values of both types can be assigned, no error occurs.",
    "question": "let id: string | number = \"user-123\";\nid = 456;",
    "answer": true
  },
  {
    "id": 2,
    "difficultyLevel": "BEGINNER",
    "category": "배열 타입 (Array Types)",
    "category_en": "Array Types",
    "explanation": "'items' 배열은 'string' 타입의 요소만 받도록 선언되었습니다. 'number' 타입인 123을 추가하려고 했기 때문에 타입 불일치로 컴파일 에러가 발생합니다.",
    "explanation_en": "The 'items' array is declared to only accept elements of type 'string'. A compile error occurs due to a type mismatch from attempting to add the number 123.",
    "question": "let items: string[] = [\"Apple\", \"Banana\"];\nitems.push(123);",
    "answer": false
  },
  {
    "id": 3,
    "difficultyLevel": "BEGINNER",
    "category": "함수 기본",
    "category_en": "Function Basics",
    "explanation": "함수가 'number' 타입의 인자를 기대하고 있고, 호출 시 'number' 타입의 값을 정확히 전달했습니다. 타입이 일치하므로 에러가 발생하지 않습니다.",
    "explanation_en": "The function expects an argument of type 'number', and a value of type 'number' was correctly passed during the call. No error occurs as the types match.",
    "question": "function printScore(score: number): void {\n  console.log(`Score: ${score}`);\n}\n\nprintScore(100);",
    "answer": true
  },
  {
    "id": 4,
    "difficultyLevel": "BEGINNER",
    "category": "any 타입",
    "category_en": "any Type",
    "explanation": "'any' 타입은 모든 타입 검사를 비활성화합니다. 따라서 'config' 객체에 'log'라는 메서드가 실제로는 존재하지 않더라도, 컴파일 시점에는 에러를 발생시키지 않습니다. (단, 실행 시에는 런타임 에러가 발생합니다.)",
    "explanation_en": "The 'any' type disables all type checking. Therefore, even if a method named 'log' does not actually exist on the 'config' object, it will not cause a compile-time error. (However, a runtime error will occur upon execution.)",
    "question": "const config: any = { setting: \"on\" };\nconfig.log();",
    "answer": true
  },
  {
    "id": 5,
    "difficultyLevel": "BEGINNER",
    "category": "튜플 타입 (Tuple Types)",
    "category_en": "Tuple Types",
    "explanation": "튜플은 정의된 순서와 타입에 맞는 요소들의 배열입니다. 'person' 변수는 [string, number] 순서의 튜플로, 할당된 값의 타입과 순서가 일치하므로 에러가 없습니다.",
    "explanation_en": "Tuples are arrays with a fixed number of elements whose types are known. The 'person' variable is a tuple of type [string, number], and the assigned value's types and order match, so there is no error.",
    "question": "let person: [string, number];\nperson = [\"John\", 42];",
    "answer": true
  },
  {
    "id": 6,
    "difficultyLevel": "BEGINNER",
    "category": "Readonly 프로퍼티",
    "category_en": "Readonly Properties",
    "explanation": "'id' 프로퍼티는 'readonly'로 선언되었기 때문에, 초기화된 이후에는 값을 재할당할 수 없습니다. 재할당을 시도했으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "The 'id' property is declared as 'readonly', so it cannot be reassigned after initialization. Attempting to reassign it causes a compile error.",
    "question": "interface User {\n  readonly id: number;\n  name: string;\n}\n\nconst user: User = { id: 1, name: \"Admin\" };\nuser.id = 2;",
    "answer": false
  },
  {
    "id": 7,
    "difficultyLevel": "BEGINNER",
    "category": "Enum (열거형)",
    "category_en": "Enums",
    "explanation": "Enum 타입으로 변수를 선언하고, 해당 Enum의 멤버를 할당하는 것은 올바른 사용법입니다. 타입이 일치하므로 에러가 없습니다.",
    "explanation_en": "Declaring a variable with an Enum type and assigning a member of that Enum is correct usage. The types match, so there is no error.",
    "question": "enum Direction {\n  Up,\n  Down,\n  Left,\n  Right\n}\n\nlet myDirection: Direction = Direction.Up;",
    "answer": true
  },
  {
    "id": 8,
    "difficultyLevel": "BEGINNER",
    "category": "unknown 타입",
    "category_en": "unknown Type",
    "explanation": "'unknown' 타입은 'any'와 달리, 타입을 먼저 확인(타입 가드)하거나 단언하지 않으면 프로퍼티에 접근하거나 메서드를 호출할 수 없습니다. 타입 확인 절차가 없으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "Unlike 'any', the 'unknown' type does not allow accessing properties or calling methods without first asserting or narrowing the type (using a type guard). A compile error occurs because no type check is performed.",
    "question": "let value: unknown = \"Hello World\";\nconsole.log(value.length);",
    "answer": false
  },
  {
    "id": 9,
    "difficultyLevel": "BEGINNER",
    "category": "옵셔널 파라미터와 Nullish Coalescing",
    "category_en": "Optional Parameters and Nullish Coalescing",
    "explanation": "함수의 'message' 파라미터는 '?'로 선택적이며, 호출 시 인자를 전달하지 않아도 됩니다. 함수 내부에서는 '??' 연산자를 사용해 undefined일 경우 기본값을 안전하게 처리하므로 에러가 없습니다.",
    "explanation_en": "The function's 'message' parameter is optional ('?'), so it can be called without an argument. Inside the function, the '??' operator safely handles the case where 'message' is undefined by providing a default value, so there is no error.",
    "question": "function log(message?: string) {\n  console.log(message ?? \"No message provided\");\n}\n\nlog();",
    "answer": true
  },
  {
    "id": 10,
    "difficultyLevel": "INTERMEDIATE",
    "category": "교차 타입 (Intersection Types)",
    "category_en": "Intersection Types",
    "explanation": "교차 타입(&)은 여러 타입을 하나로 합칩니다. 'ElevatedEmployee'는 'Admin'과 'Employee'의 모든 프로퍼티를 가져야 합니다. 'e1' 객체는 모든 필수 프로퍼티를 가지고 있으므로 타입이 올바릅니다.",
    "explanation_en": "An intersection type (&) combines multiple types into one. 'ElevatedEmployee' must have all properties of both 'Admin' and 'Employee'. The 'e1' object has all the required properties, so its type is correct.",
    "question": "type Admin = { name: string; privileges: string[]; };\ntype Employee = { name: string; startDate: Date; };\n\ntype ElevatedEmployee = Admin & Employee;\n\nconst e1: ElevatedEmployee = {\n  name: \"Alice\",\n  privileges: [\"create-server\"],\n  startDate: new Date()\n};",
    "answer": true
  },
  {
    "id": 11,
    "difficultyLevel": "INTERMEDIATE",
    "category": "제네릭 없는 함수 추론",
    "category_en": "Function Inference without Generics",
    "explanation": "제네릭을 사용하지 않으면, 타입스크립트는 입력된 유니언 타입을 기반으로 가장 넓은 범위의 반환 타입을 추론합니다. 따라서 반환 타입은 string[]이 아닌 (string | number)[]가 됩니다. 코드는 에러 없이 실행됩니다.",
    "explanation_en": "Without generics, TypeScript infers the widest possible return type based on the input union type. Therefore, the return type becomes (string | number)[] instead of string[]. The code runs without error.",
    "question": "function wrapInArray(obj: string | number) {\n  return [obj];\n}\n\nconst result = wrapInArray(\"hello\");",
    "answer": true
  },
  {
    "id": 12,
    "difficultyLevel": "INTERMEDIATE",
    "category": "유니언 타입의 공통 프로퍼티",
    "category_en": "Common Properties in Union Types",
    "explanation": "유니언 타입으로 선언된 변수는 유니언을 구성하는 모든 타입에 공통으로 존재하는 프로퍼티에만 안전하게 접근할 수 있습니다. 'layEggs'는 'Bird'와 'Fish' 모두에 있으므로 에러 없이 호출할 수 있습니다.",
    "explanation_en": "A variable declared with a union type can only safely access properties that are common to all types in the union. 'layEggs' exists in both 'Bird' and 'Fish', so it can be called without error.",
    "question": "interface Bird { fly(): void; layEggs(): void; }\ninterface Fish { swim(): void; layEggs(): void; }\n\nfunction getPet(): Bird | Fish {\n  \n  return { fly(){}, swim(){}, layEggs(){} } as Fish;\n}\n\nconst pet = getPet();\npet.layEggs();",
    "answer": true
  },
  {
    "id": 13,
    "difficultyLevel": "INTERMEDIATE",
    "category": "클래스와 'this' 컨텍스트",
    "category_en": "Classes and 'this' Context",
    "explanation": "클래스의 메서드를 변수에 할당하여 호출하면 'this'의 컨텍스트를 잃어버립니다. 'greetFunction()' 호출 시 'this'는 'undefined'가 되어 'this.greeting'에 접근할 수 없습니다. 컴파일 에러는 없지만, 런타임 에러가 발생합니다. (strict 모드 기준)",
    "explanation_en": "When a class method is assigned to a variable and then called, it loses its 'this' context. When 'greetFunction()' is called, 'this' becomes 'undefined', making it impossible to access 'this.greeting'. There is no compile error, but a runtime error occurs (in strict mode).",
    "question": "class Greeter {\n  greeting: string;\n  constructor(message: string) { this.greeting = message; }\n\n  greet() { return \"Hello, \" + this.greeting; }\n}\n\nconst greeter = new Greeter(\"world\");\nconst greetFunction = greeter.greet;\nconsole.log(greetFunction());",
    "answer": true
  },
  {
    "id": 14,
    "difficultyLevel": "INTERMEDIATE",
    "category": "유틸리티 타입: Pick",
    "category_en": "Utility Type: Pick",
    "explanation": "'Pick<T, K>'는 타입 T에서 프로퍼티 K의 집합을 선택하여 새로운 타입을 만듭니다. 'UserAge'는 { age: number } 타입이 되며, 'userAge' 객체는 이 타입에 완벽히 부합합니다.",
    "explanation_en": "'Pick<T, K>' creates a new type by picking a set of properties K from type T. 'UserAge' becomes the type { age: number }, and the 'userAge' object perfectly matches this type.",
    "question": "type User = { name: string; age: number; };\n\ntype UserAge = Pick<User, \"age\">;\n\nconst userAge: UserAge = { age: 30 };",
    "answer": true
  },
  {
    "id": 15,
    "difficultyLevel": "INTERMEDIATE",
    "category": "유틸리티 타입: Omit",
    "category_en": "Utility Type: Omit",
    "explanation": "'Omit<T, K>'는 타입 T에서 프로퍼티 K를 제거한 새로운 타입을 만듭니다. 'user' 객체는 'email'이 제거된 'UserWithoutEmail' 타입에 부합하므로 에러가 없습니다.",
    "explanation_en": "'Omit<T, K>' creates a new type by removing properties K from type T. The 'user' object conforms to the 'UserWithoutEmail' type, from which 'email' has been removed, so there is no error.",
    "question": "type User = { name: string; age: number; email: string; };\n\ntype UserWithoutEmail = Omit<User, \"email\">;\n\nconst user: UserWithoutEmail = {\n  name: \"Bob\",\n  age: 40\n};",
    "answer": true
  },
  {
    "id": 16,
    "difficultyLevel": "INTERMEDIATE",
    "category": "유틸리티 타입: Exclude vs Extract",
    "category_en": "Utility Types: Exclude vs Extract",
    "explanation": "'Exclude'는 첫 번째 유니언에서 두 번째 유니언에 포함된 타입을 제외합니다. 'Extract'는 첫 번째 유니언에서 두 번째 유니언에도 존재하는 타입만 추출합니다. 두 변수 모두 추론된 타입에 맞는 값을 할당받았으므로 에러가 없습니다.",
    "explanation_en": "'Exclude' removes types from the first union that are included in the second. 'Extract' extracts types from the first union that also exist in the second. Both variables are assigned values that match their inferred types, so there is no error.",
    "question": "type T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\ntype T1 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;\n\nconst val: T0 = \"b\";\nconst val2: T1 = \"a\";",
    "answer": true
  },
  {
    "id": 17,
    "difficultyLevel": "INTERMEDIATE",
    "category": "타입 가드: instanceof",
    "category_en": "Type Guard: instanceof",
    "explanation": "'instanceof' 연산자는 유니언 타입을 좁히는 타입 가드 역할을 합니다. if 블록 안에서 x는 'Date' 타입으로, else 블록 안에서는 'string' 타입으로 안전하게 취급되므로 에러가 없습니다.",
    "explanation_en": "The 'instanceof' operator acts as a type guard to narrow a union type. Inside the if block, x is safely treated as type 'Date', and in the else block, it's treated as type 'string'. There is no error.",
    "question": "function logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString());\n  } else {\n    console.log(x.toUpperCase());\n  }\n}",
    "answer": true
  },
  {
    "id": 18,
    "difficultyLevel": "INTERMEDIATE",
    "category": "유틸리티 타입: Partial",
    "category_en": "Utility Type: Partial",
    "explanation": "'Partial<User>'는 모든 프로퍼티를 옵셔널로 만듭니다. 따라서 'updateUser' 함수 내에서 'user.name'은 'undefined'일 수 있습니다. 'undefined'에 '.toUpperCase()'를 호출하면 런타임 에러가 발생하며, 이는 컴파일 시점에 감지되므로 컴파일 에러가 발생합니다.",
    "explanation_en": "'Partial<User>' makes all properties optional. Therefore, inside the 'updateUser' function, 'user.name' can be 'undefined'. Calling '.toUpperCase()' on 'undefined' causes a runtime error, which is detected at compile time, resulting in a compile error.",
    "question": "type User = { name: string; age: number; };\nfunction updateUser(user: Partial<User>) {\n  console.log(user.name.toUpperCase());\n}\n\nupdateUser({ age: 31 });",
    "answer": false
  },
  {
    "id": 19,
    "difficultyLevel": "INTERMEDIATE",
    "category": "판별된 유니언 (Discriminated Unions)",
    "category_en": "Discriminated Unions",
    "explanation": "'status' 프로퍼티는 유니언 타입을 구별하는 판별자 역할을 합니다. if (res.status === \"success\") 블록 안에서 'res'의 타입은 { status: \"success\"; data: any; }로 좁혀집니다. 이 타입에는 'error' 프로퍼티가 없으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "The 'status' property acts as a discriminant to distinguish between types in the union. Inside the if (res.status === \"success\") block, the type of 'res' is narrowed to { status: \"success\"; data: any; }. This type does not have an 'error' property, so a compile error occurs.",
    "question": "type ResponseData = { status: \"success\"; data: any; } | { status: \"error\"; error: Error; };\n\nfunction handleResponse(res: ResponseData) {\n  if (res.status === \"success\") {\n    console.log(res.error);\n  }\n}",
    "answer": false
  },
  {
    "id": 20,
    "difficultyLevel": "EXPERT",
    "category": "타입 브랜딩 (Nominal Typing)",
    "category_en": "Nominal Typing (Branding)",
    "explanation": "타입 브랜딩은 같은 기본 타입(string)이라도 명목상 다른 타입으로 취급하게 만드는 기법입니다. 'getUser' 함수는 브랜딩된 'UserID' 타입을 기대하지만, 일반 'string' 값을 전달했습니다. 두 타입은 호환되지 않으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "Type branding is a technique to treat types with the same underlying structure as nominally different. The 'getUser' function expects the branded 'UserID' type, but a plain 'string' was passed. The two types are not compatible, resulting in a compile error.",
    "question": "type UserID = string & { readonly brand: unique symbol };\n\nfunction UserID(id: string): UserID {\n  return id as UserID;\n}\n\nfunction getUser(id: UserID) {\n  console.log(id);\n}\n\ngetUser(\"user-123\");",
    "answer": false
  },
  {
    "id": 21,
    "difficultyLevel": "EXPERT",
    "category": "매핑된 타입 (Mapped Types)",
    "category_en": "Mapped Types",
    "explanation": "매핑된 타입을 사용해 'Routes' 유니언의 각 멤버를 키로 갖는 객체 타입을 정의했습니다. 'config' 객체는 'RouteConfig' 타입의 모든 요구사항을 만족하므로 에러가 없습니다.",
    "explanation_en": "A mapped type was used to define an object type where the keys are members of the 'Routes' union. The 'config' object satisfies all requirements of the 'RouteConfig' type, so there is no error.",
    "question": "type Routes = \"/\" | \"/about\" | \"/contact\";\ntype RouteConfig = { [K in Routes]: { component: string } };\n\nconst config: RouteConfig = {\n  \"/\": { component: \"Home\" },\n  \"/about\": { component: \"About\" },\n  \"/contact\": { component: \"Contact\" }\n};",
    "answer": true
  },
  {
    "id": 22,
    "difficultyLevel": "EXPERT",
    "category": "조건부 타입과 infer",
    "category_en": "Conditional Types and infer",
    "explanation": "'UnpackPromise'는 조건부 타입을 사용해 T가 Promise일 경우 그 내부 타입을 'infer'(추론)하여 반환합니다. 'ReturnType<typeof fetchData>'는 'Promise<string>'이므로 'Data' 타입은 'string'이 됩니다. 'myData'는 'string' 타입이므로 에러가 없습니다.",
    "explanation_en": "'UnpackPromise' uses a conditional type to 'infer' and return the inner type U if T is a Promise. Since 'ReturnType<typeof fetchData>' is 'Promise<string>', the type 'Data' becomes 'string'. 'myData' is of type 'string', so there is no error.",
    "question": "type UnpackPromise<T> = T extends Promise<infer U> ? U : T;\n\nasync function fetchData() { return \"some data\"; }\n\ntype Data = UnpackPromise<ReturnType<typeof fetchData>>;\n\nconst myData: Data = \"hello\";",
    "answer": true
  },
  {
    "id": 23,
    "difficultyLevel": "EXPERT",
    "category": "유틸리티 타입: NonNullable과 never",
    "category_en": "Utility Type: NonNullable and never",
    "explanation": "'NonNullable<T>'는 T에서 null과 undefined를 제거하는 유틸리티 타입입니다. 'MustBeString'은 'string' 타입이 됩니다. 'null' 값을 'string' 타입 변수에 할당하려고 했으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "'NonNullable<T>' is a utility type that removes null and undefined from T. 'MustBeString' becomes type 'string'. Attempting to assign 'null' to a variable of type 'string' causes a compile error.",
    "question": "type NonNullable<T> = T extends null | undefined ? never : T;\ntype MaybeString = string | null | undefined;\ntype MustBeString = NonNullable<MaybeString>;\n\nconst str: MustBeString = null;",
    "answer": false
  },
  {
    "id": 24,
    "difficultyLevel": "EXPERT",
    "category": "satisfies 연산자",
    "category_en": "satisfies Operator",
    "explanation": "'satisfies' 연산자는 표현식이 특정 타입을 만족하는지 검사하면서도, 표현식 자체의 구체적인 타입은 그대로 유지합니다. 'user' 객체는 'User' 타입을 만족하며(email은 옵셔널), 동시에 {id, name, role} 이라는 구체적인 타입을 가집니다. 따라서 'user.role' 접근이 가능하며 에러가 없습니다.",
    "explanation_en": "The 'satisfies' operator checks if an expression conforms to a certain type while preserving the expression's own specific type. The 'user' object satisfies the 'User' type (email is optional) and simultaneously has the specific type {id, name, role}. Therefore, accessing 'user.role' is possible and causes no error.",
    "question": "type User = {\n  id: number;\n  name: string;\n  email?: string;\n}\n\nconst user = {\n  id: 1,\n  name: \"Alice\",\n  role: \"admin\" \n} satisfies User;\n\nconsole.log(user.role);",
    "answer": true
  },
  {
    "id": 25,
    "difficultyLevel": "EXPERT",
    "category": "매핑된 타입과 조건부 타입",
    "category_en": "Mapped and Conditional Types",
    "explanation": "'Person' 타입은 { name: string; age: number; }로 해석됩니다. 'p' 객체는 필수 프로퍼티인 'name'이 누락되었으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "The 'Person' type resolves to { name: string; age: number; }. The 'p' object is missing the required 'name' property, which causes a compile error.",
    "question": "type Keys = \"name\" | \"age\";\n\ntype Person = { [K in Keys]: K extends \"name\" ? string : number };\n\nconst p: Person = { age: 30 };",
    "answer": false
  },
  {
    "id": 26,
    "difficultyLevel": "EXPERT",
    "category": "가변 튜플 타입 (Variadic Tuple Types)",
    "category_en": "Variadic Tuple Types",
    "explanation": "'...'를 튜플 타입에 사용하여 가변적인 길이를 가진 튜플 타입을 표현할 수 있습니다. 'combine' 함수는 두 배열/튜플을 받아 정확한 타입 시퀀스를 가진 새로운 튜플 타입을 반환합니다. 타입 추론이 정확하게 이루어지므로 에러가 없습니다.",
    "explanation_en": "The '...' syntax can be used in tuple types to represent tuples of variable length. The 'combine' function takes two arrays/tuples and returns a new tuple type with a precise type sequence. Type inference works correctly, so there is no error.",
    "question": "function combine<T extends any[], U extends any[]>(arr1: T, arr2: U): [...T, ...U] {\n  return [...arr1, ...arr2];\n}\n\nconst combined = combine([1, 2], [\"a\", \"b\"]);\n\nconst first = combined[0]; \nconst third = combined[2];",
    "answer": true
  },
  {
    "id": 27,
    "difficultyLevel": "EXPERT",
    "category": "매핑된 타입 키 리매핑 (Key Remapping)",
    "category_en": "Key Remapping in Mapped Types",
    "explanation": "매핑된 타입의 'as' 절을 이용해 프로퍼티 키의 이름을 변경할 수 있습니다. 'CircleGetters'는 { getRadius: () => number; getColor: () => string; } 타입이 됩니다. 'circleGetters' 객체는 이 타입을 완벽하게 구현했으므로 에러가 없습니다.",
    "explanation_en": "The 'as' clause in a mapped type can be used to rename property keys. 'CircleGetters' becomes the type { getRadius: () => number; getColor: () => string; }. The 'circleGetters' object perfectly implements this type, so there is no error.",
    "question": "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\n\ninterface Circle { radius: number; color: string; }\ntype CircleGetters = Getters<Circle>;\n\nconst circleGetters: CircleGetters = {\n  getRadius: () => 10,\n  getColor: () => \"red\"\n};",
    "answer": true
  },
  {
    "id": 28,
    "difficultyLevel": "EXPERT",
    "category": "분배적 조건부 타입 (Distributive Conditional Types)",
    "category_en": "Distributive Conditional Types",
    "explanation": "조건부 타입의 제네릭이 유니언 타입일 경우, 각 타입에 개별적으로 적용되어 결과가 다시 유니언으로 묶입니다(분배적 동작). 따라서 'StrOrNumArray'는 'string[] | number[]'가 됩니다. 이 타입은 \"문자열만 있는 배열\" 또는 \"숫자만 있는 배열\"을 의미하므로, 두 타입이 섞인 배열은 할당할 수 없어 컴파일 에러가 발생합니다.",
    "explanation_en": "When the generic in a conditional type is a union type, it is applied to each member of the union individually, and the results are unioned back together (distributive behavior). Therefore, 'StrOrNumArray' becomes 'string[] | number[]'. This type means 'an array of only strings' or 'an array of only numbers', so an array containing a mix of both types cannot be assigned, causing a compile error.",
    "question": "type ToArray<T> = T extends any ? T[] : never;\n\ntype StrOrNumArray = ToArray<string | number>;\n\nconst arr: StrOrNumArray = [\"hello\", 1];",
    "answer": false
  },
  {
    "id": 29,
    "difficultyLevel": "EXPERT",
    "category": "판별된 유니언과 타입 좁히기",
    "category_en": "Discriminated Unions and Type Narrowing",
    "explanation": "'kind' 프로퍼티를 사용해 타입을 좁혔습니다. if 블록 안에서 'obj'의 타입은 'A'로 확정됩니다. 'A' 타입에는 'b' 프로퍼티가 없으므로, 'obj.b'에 접근하려는 시도는 컴파일 에러를 발생시킵니다.",
    "explanation_en": "The 'kind' property is used to narrow the type. Inside the if block, the type of 'obj' is confirmed to be 'A'. Since type 'A' does not have a 'b' property, attempting to access 'obj.b' causes a compile error.",
    "question": "type A = { kind: 'a', a: string };\ntype B = { kind: 'b', b: string };\n\nfunction process(obj: A | B) {\n  \n  if (obj.kind === 'a') {\n    console.log(obj.b);\n  }\n}",
    "answer": false
  },
  {
    "id": 30,
    "difficultyLevel": "BEGINNER",
    "category": "타입 단언 (Type Assertion)",
    "category_en": "Type Assertion",
    "explanation": "'any' 타입의 값을 'as' 키워드를 사용해 'string'으로 단언했습니다. 타입스크립트는 개발자의 단언을 신뢰하므로, 컴파일 시점에는 에러가 발생하지 않습니다. 해당 값이 실제로 문자열이므로 런타임 에러도 없습니다.",
    "explanation_en": "The value of type 'any' was asserted as 'string' using the 'as' keyword. TypeScript trusts the developer's assertion, so no compile-time error occurs. Since the value is actually a string, there is no runtime error either.",
    "question": "let value: any = 'this is a string';\nlet len: number = (value as string).length;",
    "answer": true
  },
  {
    "id": 31,
    "difficultyLevel": "BEGINNER",
    "category": "함수 반환 타입: never",
    "category_en": "Function Return Type: never",
    "explanation": "'never' 타입은 함수가 절대 반환하지 않음을 의미합니다. 항상 예외를 던지거나 무한 루프에 빠지는 함수에 사용됩니다. 이 함수는 항상 예외를 던지므로 'never' 타입이 올바르게 사용되었습니다.",
    "explanation_en": "The 'never' type indicates that a function never returns. It's used for functions that always throw an exception or enter an infinite loop. This function always throws an exception, so the 'never' type is used correctly.",
    "question": "function throwError(message: string): never {\n  throw new Error(message);\n}",
    "answer": true
  },
  {
    "id": 32,
    "difficultyLevel": "BEGINNER",
    "category": "객체 리터럴 타입 추론",
    "category_en": "Object Literal Type Inference",
    "explanation": "변수 'user'는 { name: string; age: number; } 타입으로 추론됩니다. 'age' 프로퍼티는 'number' 타입인데, 'string' 타입의 값을 할당하려고 시도했으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "The variable 'user' is inferred to have the type { name: string; age: number; }. The 'age' property is of type 'number', so attempting to assign a 'string' value to it causes a compile error.",
    "question": "let user = { name: 'John', age: 30 };\nuser.age = 'thirty';",
    "answer": false
  },
  {
    "id": 33,
    "difficultyLevel": "BEGINNER",
    "category": "void 반환 타입",
    "category_en": "void Return Type",
    "explanation": "'void'는 함수가 명시적으로 아무것도 반환하지 않음을 나타냅니다. 'logMessage' 함수는 값을 반환하지 않으므로, 반환 타입을 'void'로 지정하는 것은 올바릅니다.",
    "explanation_en": "'void' indicates that a function does not explicitly return anything. The 'logMessage' function does not return a value, so specifying its return type as 'void' is correct.",
    "question": "function logMessage(message: string): void {\n  console.log(message);\n}",
    "answer": true
  },
  {
    "id": 34,
    "difficultyLevel": "BEGINNER",
    "category": "타입 별칭 (Type Alias)",
    "category_en": "Type Alias",
    "explanation": "타입 별칭을 사용해 'string | number' 타입을 'StringOrNumber'로 정의했습니다. 'id' 변수는 이 타입에 부합하는 값들을 할당받고 있으므로 에러가 없습니다.",
    "explanation_en": "A type alias was used to define the type 'StringOrNumber' as 'string | number'. The 'id' variable is assigned values that conform to this type, so there is no error.",
    "question": "type StringOrNumber = string | number;\nlet id: StringOrNumber = 'ID-001';\nid = 12345;",
    "answer": true
  },
  {
    "id": 35,
    "difficultyLevel": "BEGINNER",
    "category": "null과 undefined",
    "category_en": "null vs undefined",
    "explanation": "'null'은 값이 없음을 의도적으로 명시하는 것이고, 'undefined'는 값이 할당되지 않았음을 의미합니다. 'string' 타입의 변수에 'null'을 할당할 수 없으므로 컴파일 에러가 발생합니다. (`strictNullChecks` 옵션 활성화 기준)",
    "explanation_en": "'null' is an intentional absence of any object value, while 'undefined' means a variable has not been assigned a value. You cannot assign 'null' to a variable of type 'string', resulting in a compile error (assuming the `strictNullChecks` option is enabled).",
    "question": "let name: string = 'Alice';\nname = null;",
    "answer": false
  },
  {
    "id": 36,
    "difficultyLevel": "BEGINNER",
    "category": "템플릿 리터럴 타입",
    "category_en": "Template Literal Types",
    "explanation": "템플릿 리터럴을 사용해 문자열의 형식을 지정하는 타입을 만들 수 있습니다. 'userId' 변수는 'user_'로 시작하고 숫자로 끝나는 문자열 타입에 부합하므로 에러가 없습니다.",
    "explanation_en": "Template literals can be used to create types that specify the format of a string. The 'userId' variable conforms to the type of a string that starts with 'user_' and ends with a number, so there is no error.",
    "question": "type UserID = `user_${number}`;\nlet userId: UserID = 'user_123';",
    "answer": true
  },
  {
    "id": 37,
    "difficultyLevel": "BEGINNER",
    "category": "함수 오버로딩",
    "category_en": "Function Overloading",
    "explanation": "함수 오버로딩을 사용하면 하나의 함수가 여러 다른 타입의 인자를 받을 수 있음을 선언할 수 있습니다. 하지만 오버로드 선언부 중 어느 것과도 일치하지 않는 `[1, 2, 3]`을 인자로 전달했으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "Function overloading allows you to declare that a single function can accept arguments of different types. However, a compile error occurs because the argument `[1, 2, 3]` does not match any of the overload signatures.",
    "question": "function double(x: string): string;\nfunction double(x: number): number;\nfunction double(x: any) { \n  if (typeof x === 'string') return x + x;\n  if (typeof x === 'number') return x * 2;\n}\ndouble([1, 2, 3]);",
    "answer": false
  },
  {
    "id": 38,
    "difficultyLevel": "BEGINNER",
    "category": "인터페이스 확장",
    "category_en": "Interface Extension",
    "explanation": "'Admin' 인터페이스는 'User' 인터페이스를 확장했습니다. 따라서 'Admin' 타입의 객체는 'User'와 'Admin'의 모든 프로퍼티를 가져야 합니다. 'adminUser'는 'role' 프로퍼티가 누락되었으므로 에러가 발생합니다.",
    "explanation_en": "The 'Admin' interface extends the 'User' interface. Therefore, an object of type 'Admin' must have all properties from both 'User' and 'Admin'. 'adminUser' is missing the 'role' property, so an error occurs.",
    "question": "interface User { id: number; }\ninterface Admin extends User { role: string; }\nconst adminUser: Admin = { id: 1 };",
    "answer": false
  },
  {
    "id": 39,
    "difficultyLevel": "BEGINNER",
    "category": "인덱스 시그니처",
    "category_en": "Index Signatures",
    "explanation": "인덱스 시그니처를 사용하면 객체가 임의의 키와 특정 타입의 값을 가질 수 있음을 정의할 수 있습니다. 'ages' 객체의 'Jane' 프로퍼티에 'number' 타입이 아닌 'string'을 할당했으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "Index signatures can define that an object can have arbitrary keys with values of a specific type. A compile error occurs because a 'string' is assigned to the 'Jane' property of the 'ages' object, which expects a 'number' type.",
    "question": "const ages: { [index: string]: number } = {};\nages.John = 30;\nages.Jane = 'twenty-five';",
    "answer": false
  },
  {
    "id": 40,
    "difficultyLevel": "INTERMEDIATE",
    "category": "타입 가드: is",
    "category_en": "Type Guard: is",
    "explanation": "'is' 키워드를 사용한 사용자 정의 타입 가드 함수입니다. 'isString' 함수가 true를 반환하면, if 블록 내에서 'foo'의 타입은 'string'으로 좁혀집니다. 따라서 '.length' 프로퍼티에 안전하게 접근할 수 있습니다.",
    "explanation_en": "This is a user-defined type guard function using the 'is' keyword. If the 'isString' function returns true, the type of 'foo' is narrowed to 'string' within the if block. Therefore, its '.length' property can be safely accessed.",
    "question": "function isString(test: any): test is string {\n  return typeof test === 'string';\n}\n\nlet foo: unknown = 'hello';\nif (isString(foo)) {\n  console.log(foo.length);\n}",
    "answer": true
  },
  {
    "id": 41,
    "difficultyLevel": "INTERMEDIATE",
    "category": "유틸리티 타입: Record",
    "category_en": "Utility Type: Record",
    "explanation": "'Record<K, T>'는 키가 K이고 값이 T인 객체 타입을 생성합니다. 'PageInfo'는 키가 'home', 'about', 'contact' 중 하나이고 값이 { title: string }인 객체를 의미합니다. 'pages' 객체는 이 타입에 부합하지 않으므로 컴파일 에러가 발생합니다. ('contact' 프로퍼티의 값이 잘못됨)",
    "explanation_en": "'Record<K, T>' creates an object type with keys of type K and values of type T. 'PageInfo' represents an object where keys are one of 'home', 'about', 'contact', and values are { title: string }. The 'pages' object does not conform to this type because the value of the 'contact' property is incorrect, resulting in a compile error.",
    "question": "type Page = 'home' | 'about' | 'contact';\ntype PageInfo = Record<Page, { title: string }>;\n\nconst pages: PageInfo = {\n  home: { title: 'Home' },\n  about: { title: 'About' },\n  contact: { title: 123 }\n};",
    "answer": false
  },
  {
    "id": 42,
    "difficultyLevel": "INTERMEDIATE",
    "category": "제네릭과 기본값",
    "category_en": "Generics with Defaults",
    "explanation": "제네릭 타입에 기본값을 지정할 수 있습니다. 'create' 함수 호출 시 타입을 명시하지 않으면 기본값인 'boolean'이 사용됩니다. 'create()'는 'boolean[]' 타입의 배열을 반환하므로 에러가 없습니다.",
    "explanation_en": "Default values can be specified for generic types. If no type is specified when calling the 'create' function, the default value 'boolean' is used. 'create()' returns an array of type 'boolean[]', so there is no error.",
    "question": "function create<T = boolean>(): T[] {\n  return [];\n}\nconst bools = create();",
    "answer": true
  },
  {
    "id": 43,
    "difficultyLevel": "INTERMEDIATE",
    "category": "추상 클래스",
    "category_en": "Abstract Classes",
    "explanation": "추상 클래스는 직접 인스턴스화할 수 없습니다. 상속을 통해서만 사용될 수 있습니다. 'new Department()'는 추상 클래스의 인스턴스를 직접 생성하려고 시도했기 때문에 컴파일 에러가 발생합니다.",
    "explanation_en": "Abstract classes cannot be instantiated directly. They can only be used through inheritance. 'new Department()' attempts to create an instance of an abstract class directly, which results in a compile error.",
    "question": "abstract class Department {\n  constructor(public name: string) {}\n  abstract getInfo(): void;\n}\n\nconst accounting = new Department('Accounting');",
    "answer": false
  },
  {
    "id": 44,
    "difficultyLevel": "INTERMEDIATE",
    "category": "유틸리티 타입: Required",
    "category_en": "Utility Type: Required",
    "explanation": "'Required<T>'는 T의 모든 프로퍼티를 필수로 만듭니다. 'Props'의 'c'는 선택적이었지만 'RequiredProps'에서는 필수가 됩니다. 'props' 객체는 필수 프로퍼티 'c'가 누락되었으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "'Required<T>' makes all properties of T mandatory. Although 'c' in 'Props' was optional, it becomes required in 'RequiredProps'. The 'props' object is missing the required property 'c', resulting in a compile error.",
    "question": "interface Props {\n  a?: number;\n  b?: string;\n  c?: boolean;\n}\n\ntype RequiredProps = Required<Props>;\nconst props: RequiredProps = { a: 1, b: 'test' };",
    "answer": false
  },
  {
    "id": 45,
    "difficultyLevel": "INTERMEDIATE",
    "category": "타입 가드: in",
    "category_en": "Type Guard: in",
    "explanation": "'in' 연산자는 객체에 특정 프로퍼티가 있는지 확인하여 타입을 좁히는 타입 가드입니다. if 블록 안에서 'pet'은 'Fish' 타입으로 간주되므로 '.swim()' 호출이 가능합니다.",
    "explanation_en": "The 'in' operator is a type guard that narrows a type by checking for the existence of a specific property on an object. Inside the if block, 'pet' is considered to be of type 'Fish', so calling '.swim()' is valid.",
    "question": "interface Bird { fly(): void; }\ninterface Fish { swim(): void; }\n\nfunction move(pet: Bird | Fish) {\n  if ('swim' in pet) {\n    return pet.swim();\n  }\n  return pet.fly();\n}",
    "answer": true
  },
  {
    "id": 46,
    "difficultyLevel": "INTERMEDIATE",
    "category": "클래스 프로퍼티 초기화",
    "category_en": "Class Property Initialization",
    "explanation": "클래스 프로퍼티는 선언 시점이나 생성자 내에서 초기화되어야 합니다. 'name' 프로퍼티가 초기화되지 않았으므로 컴파일 에러가 발생합니다. (`strictPropertyInitialization` 옵션 활성화 기준)",
    "explanation_en": "Class properties must be initialized either at the point of declaration or within the constructor. The 'name' property is not initialized, which causes a compile error (assuming the `strictPropertyInitialization` option is enabled).",
    "question": "class Player {\n  name: string;\n  score: number = 0;\n}",
    "answer": false
  },
  {
    "id": 47,
    "difficultyLevel": "INTERMEDIATE",
    "category": "제네릭 제약 조건",
    "category_en": "Generic Constraints",
    "explanation": "'T'는 'length' 프로퍼티를 가진 타입으로 제약되었습니다. 전달된 객체는 'length' 프로퍼티를 가지고 있으므로 제약 조건을 만족합니다.",
    "explanation_en": "The generic type 'T' is constrained to types that have a 'length' property. The passed object has a 'length' property, thus satisfying the constraint.",
    "question": "interface Lengthy { length: number; }\n\nfunction countAndDescribe<T extends Lengthy>(element: T): [T, string] {\n  let description = 'Got no value.';\n  if (element.length > 0) {\n    description = 'Got ' + element.length + ' elements.';\n  }\n  return [element, description];\n}\n\ncountAndDescribe({ length: 10, value: 3 });",
    "answer": true
  },
  {
    "id": 48,
    "difficultyLevel": "INTERMEDIATE",
    "category": "이터러블과 제네레이터",
    "category_en": "Iterables and Generators",
    "explanation": "제네레이터 함수는 호출 시 이터레이터 객체를 반환합니다. 이터레이터의 'next()' 메서드는 { value, done } 형태의 객체를 반환합니다. 'gen.next().value'는 1이므로 타입이 올바릅니다.",
    "explanation_en": "A generator function returns an iterator object when called. The iterator's 'next()' method returns an object of the form { value, done }. 'gen.next().value' is 1, so the type is correct.",
    "question": "function* numbers() {\n  yield 1;\n  yield 2;\n  return 3;\n}\nconst gen = numbers();\nconst val: number = gen.next().value;",
    "answer": true
  },
  {
    "id": 49,
    "difficultyLevel": "INTERMEDIATE",
    "category": "this 파라미터",
    "category_en": "this parameters",
    "explanation": "'addClickListener'의 콜백 함수 타입은 'this: void'로 지정되어 'this' 컨텍스트를 사용하지 않음을 명시합니다. 제공된 콜백은 이 요구사항을 만족하므로 에러가 없습니다.",
    "explanation_en": "The callback function type for 'addClickListener' is specified with 'this: void', indicating that it does not use a 'this' context. The provided callback satisfies this requirement, so there is no error.",
    "question": "interface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void;\n}\n\nclass Button implements UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void {}\n}\n\nconst button = new Button();\nbutton.addClickListener(function(e) {\n  console.log('clicked');\n});",
    "answer": true
  },
  {
    "id": 50,
    "difficultyLevel": "EXPERT",
    "category": "const 단언",
    "category_en": "const Assertions",
    "explanation": "'as const'는 리터럴 타입을 가장 좁은 형태로 추론하게 만듭니다. 'routes'는 ' readonly [\"/\", \"/about\"]' 타입이 되고, 'req.path'는 'string' 타입이므로 'routes' 배열에 'includes'를 사용할 수 없습니다. ('routes'는 string[] 타입이 아니기 때문)",
    "explanation_en": "'as const' makes TypeScript infer the narrowest possible type for a literal. 'routes' becomes type 'readonly [\"/\", \"/about\"]', and since 'req.path' is of type 'string', you cannot use 'includes' on the 'routes' array because 'routes' is not of type string[].",
    "question": "const routes = [\"/\", \"/about\"] as const;\ntype Routes = typeof routes[number];\n\nfunction handleRequest(path: string) {\n  if (routes.includes(path)) { \n    // ...\n  }\n}",
    "answer": false
  },
  {
    "id": 51,
    "difficultyLevel": "EXPERT",
    "category": "재귀 타입 별칭",
    "category_en": "Recursive Type Aliases",
    "explanation": "타입 별칭은 자신을 직접 참조하여 재귀적인 데이터 구조를 표현할 수 있습니다. 'Json' 타입은 문자열, 숫자, 불리언, null, 또는 자신을 값으로 가지는 배열이나 객체를 나타냅니다. 'data'는 이 구조에 부합합니다.",
    "explanation_en": "Type aliases can refer to themselves to express recursive data structures. The 'Json' type represents a string, number, boolean, null, or an array or object containing itself as values. The 'data' object conforms to this structure.",
    "question": "type Json = | string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst data: Json = {\n  name: \"data\",\n  items: [1, \"two\", { nested: true }]\n};",
    "answer": true
  },
  {
    "id": 52,
    "difficultyLevel": "EXPERT",
    "category": "템플릿 리터럴과 infer",
    "category_en": "Template Literals with infer",
    "explanation": "템플릿 리터럴 타입과 'infer'를 함께 사용하여 문자열의 일부를 추출하고 타입을 변환할 수 있습니다. 'Getters'는 'Person'의 키를 기반으로 'getName'과 'getAge'를 생성합니다. 'personGetters' 객체는 이 타입의 모든 요구사항을 만족합니다.",
    "explanation_en": "Template literal types combined with 'infer' can be used to extract parts of a string and transform types. 'Getters' generates 'getName' and 'getAge' based on the keys of 'Person'. The 'personGetters' object satisfies all requirements of this type.",
    "question": "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n}\n\ninterface Person { name: string; age: number; }\ntype PersonGetters = Getters<Person>;\n\nconst personGetters: PersonGetters = {\n    getName: () => 'John',\n    getAge: () => 30\n};",
    "answer": true
  },
  {
    "id": 53,
    "difficultyLevel": "EXPERT",
    "category": "공변성과 반공변성 (함수 타입)",
    "category_en": "Covariance and Contravariance (Function Types)",
    "explanation": "함수 매개변수는 반공변적입니다. 즉, 더 넓은 타입(Animal)을 받는 함수는 더 좁은 타입(Dog)을 받는 함수가 필요한 곳에 할당될 수 없습니다. 따라서 'logAnimal'을 'logDog'에 할당하는 것은 컴파일 에러를 유발합니다.",
    "explanation_en": "Function parameters are contravariant. This means a function that accepts a wider type (Animal) cannot be assigned to a function that expects a narrower type (Dog). Therefore, assigning 'logAnimal' to 'logDog' causes a compile error.",
    "question": "class Animal {}\nclass Dog extends Animal {}\n\nlet logDog: (d: Dog) => void = (d) => {};\nlet logAnimal: (a: Animal) => void = (a) => {};\n\nlogDog = logAnimal;",
    "answer": false
  },
  {
    "id": 54,
    "difficultyLevel": "EXPERT",
    "category": "infer와 함수 파라미터",
    "category_en": "infer with Function Parameters",
    "explanation": "'infer'를 사용하여 함수의 파라미터 타입을 추출할 수 있습니다. 'Params' 타입은 'myFunc'의 첫 번째 파라미터 타입인 'string'으로 해석됩니다. 'p'는 'string' 타입이므로 에러가 없습니다.",
    "explanation_en": "'infer' can be used to extract the type of a function's parameters. The 'Params' type is resolved to 'string', which is the type of the first parameter of 'myFunc'. 'p' is of type 'string', so there is no error.",
    "question": "type Params<F> = F extends (arg: infer P) => any ? P : never;\n\nconst myFunc = (name: string) => {};\ntype MyFuncParams = Params<typeof myFunc>;\n\nconst p: MyFuncParams = 'test';",
    "answer": true
  },
  {
    "id": 55,
    "difficultyLevel": "EXPERT",
    "category": "infer와 튜플",
    "category_en": "infer with Tuples",
    "explanation": "'Tail' 타입은 튜플의 첫 번째 요소를 제외한 나머지 부분을 추출합니다. 'MyTuple'의 'Tail'은 '[string, boolean]'이 됩니다. 'rest' 변수는 이 타입에 부합하므로 에러가 없습니다.",
    "explanation_en": "The 'Tail' type extracts the remaining part of a tuple after the first element. The 'Tail' of 'MyTuple' becomes '[string, boolean]'. The 'rest' variable conforms to this type, so there is no error.",
    "question": "type Tail<T extends any[]> = T extends [any, ...infer R] ? R : [];\n\ntype MyTuple = [number, string, boolean];\ntype MyTupleTail = Tail<MyTuple>;\n\nconst rest: MyTupleTail = ['a', true];",
    "answer": true
  },
  {
    "id": 56,
    "difficultyLevel": "EXPERT",
    "category": "인덱스 접근 타입",
    "category_en": "Indexed Access Types",
    "explanation": "인덱스 접근 타입을 사용해 다른 타입의 프로퍼티 타입을 조회할 수 있습니다. 'Person['addresses']'는 'Address[]' 타입이며, 'AddressType'은 'Address'가 됩니다. 'address' 객체는 'Address' 타입에 부합하지 않으므로 컴파일 에러가 발생합니다. ('zipCode'가 문자열임)",
    "explanation_en": "Indexed access types can be used to look up the type of a property on another type. 'Person['addresses']' is of type 'Address[]', and 'AddressType' becomes 'Address'. The 'address' object does not conform to the 'Address' type because 'zipCode' is a string, resulting in a compile error.",
    "question": "interface Address { street: string; zipCode: number; }\ninterface Person { addresses: Address[]; }\n\ntype AddressType = Person['addresses'][number];\nconst address: AddressType = { street: '123 Main St', zipCode: '12345' };",
    "answer": false
  },
  {
    "id": 57,
    "difficultyLevel": "EXPERT",
    "category": "const와 제네릭 함수",
    "category_en": "const and Generic Functions",
    "explanation": "'as const'를 사용하면 객체의 모든 프로퍼티가 'readonly'가 되고, 값은 리터럴 타입으로 추론됩니다. 'makePair'는 'readonly [T, U]'를 반환하므로, 'pair'는 'readonly [string, number]' 타입이 됩니다. 이후 'pair[0] = ...'와 같이 재할당이 불가능하므로 컴파일 에러가 발생합니다.",
    "explanation_en": "Using 'as const' makes all properties of an object 'readonly' and infers values as literal types. 'makePair' returns 'readonly [T, U]', so 'pair' has the type 'readonly [string, number]'. Reassignment like 'pair[0] = ...' is not possible, causing a compile error.",
    "question": "function makePair<T, U>(x: T, y: U) {\n  return [x, y] as const;\n}\n\nconst pair = makePair('hello', 42);\npair[0] = 'world';",
    "answer": false
  },
  {
    "id": 58,
    "difficultyLevel": "EXPERT",
    "category": "this 타입과 타입 가드",
    "category_en": "this Types and Type Guards",
    "explanation": "'this is Date'는 'isDate'가 호출된 객체가 'Date' 타입임을 단언하는 타입 가드입니다. if 블록 안에서 'this'는 'Date'로 취급됩니다. 'bind'를 통해 올바른 'this' 컨텍스트로 호출되었으므로 에러가 없습니다.",
    "explanation_en": "'this is Date' is a type guard that asserts the object on which 'isDate' is called is of type 'Date'. Inside the if block, 'this' is treated as a 'Date'. Since it's called with the correct 'this' context via 'bind', there is no error.",
    "question": "function isDate(this: any): this is Date {\n  return this instanceof Date;\n}\n\nconst maybeDate: unknown = new Date();\nif (isDate.call(maybeDate)) {\n  console.log(maybeDate.getTime());\n}",
    "answer": true
  },
  {
    "id": 59,
    "difficultyLevel": "EXPERT",
    "category": "조건부 타입 체이닝",
    "category_en": "Conditional Type Chaining",
    "explanation": "'DeepReadonly'는 재귀적으로 객체의 모든 프로퍼티를 'readonly'로 만듭니다. 'config' 객체는 'DeepReadonly' 타입이므로, 중첩된 객체의 프로퍼티('config.settings.theme')도 재할당할 수 없어 컴파일 에러가 발생합니다.",
    "explanation_en": "'DeepReadonly' recursively makes all properties of an object 'readonly'. Since the 'config' object is of type 'DeepReadonly', properties of nested objects (like 'config.settings.theme') also cannot be reassigned, resulting in a compile error.",
    "question": "type DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\nconst config = {\n  settings: { theme: 'dark' }\n};\n\nconst readonlyConfig: DeepReadonly<typeof config> = config;\nreadonlyConfig.settings.theme = 'light';",
    "answer": false
  },
  {
    "id": 60,
    "difficultyLevel": "BEGINNER",
    "category": "리터럴 타입",
    "category_en": "Literal Types",
    "explanation": "'Status' 타입은 'success' 또는 'failure' 문자열 리터럴만 허용합니다. 변수 'currentStatus'에 허용되지 않는 'pending' 문자열을 할당하려고 했으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "The 'Status' type only allows the string literals 'success' or 'failure'. A compile error occurs because an unallowed string 'pending' is being assigned to the variable 'currentStatus'.",
    "question": "type Status = 'success' | 'failure';\nlet currentStatus: Status = 'pending';",
    "answer": false
  },
  {
    "id": 61,
    "difficultyLevel": "BEGINNER",
    "category": "const와 객체 프로퍼티",
    "category_en": "const and Object Properties",
    "explanation": "'const'로 선언된 객체는 재할당이 불가능하지만, 객체 내부의 프로퍼티를 변경하는 것은 가능합니다. 'user.name' 프로퍼티를 수정하는 것은 유효한 작업입니다.",
    "explanation_en": "An object declared with 'const' cannot be reassigned, but its internal properties can be modified. Modifying the 'user.name' property is a valid operation.",
    "question": "const user = { name: 'Alice' };\nuser.name = 'Bob';",
    "answer": true
  },
  {
    "id": 62,
    "difficultyLevel": "BEGINNER",
    "category": "타입 단언의 위험성",
    "category_en": "Risks of Type Assertion",
    "explanation": "타입 단언은 컴파일러의 타입 검사를 무시하게 만듭니다. 'value'는 실제로는 숫자이지만, 'string'으로 단언되었습니다. 컴파일 에러는 없지만, '.toUpperCase()' 메서드가 없어 런타임 에러가 발생합니다.",
    "explanation_en": "Type assertion forces the compiler to ignore type checking. 'value' is actually a number but is asserted as a 'string'. There is no compile error, but a runtime error will occur because there is no '.toUpperCase()' method on a number.",
    "question": "const value: unknown = 123;\nconsole.log((value as string).toUpperCase());",
    "answer": true
  },
  {
    "id": 63,
    "difficultyLevel": "BEGINNER",
    "category": "문자열 Enum",
    "category_en": "String Enums",
    "explanation": "문자열 Enum의 멤버는 선언 시 초기화되어야 합니다. 'LogLevel'의 모든 멤버가 문자열 리터럴로 올바르게 초기화되었으므로 에러가 없습니다.",
    "explanation_en": "Members of a string enum must be initialized at declaration. All members of 'LogLevel' are correctly initialized with string literals, so there is no error.",
    "question": "enum LogLevel {\n  ERROR = 'ERROR',\n  WARN = 'WARN',\n  INFO = 'INFO'\n}\nconst level: LogLevel = LogLevel.INFO;",
    "answer": true
  },
  {
    "id": 64,
    "difficultyLevel": "BEGINNER",
    "category": "유니언 타입과 null",
    "category_en": "Union Types with null",
    "explanation": "'string | null' 유니언 타입으로 선언된 변수에는 'string' 값 또는 'null' 값을 할당할 수 있습니다. 두 할당 모두 유효하므로 에러가 없습니다.",
    "explanation_en": "A variable declared with the union type 'string | null' can be assigned either a 'string' value or 'null'. Both assignments are valid, so there is no error.",
    "question": "let name: string | null = 'Alice';\nname = null;",
    "answer": true
  },
  {
    "id": 65,
    "difficultyLevel": "INTERMEDIATE",
    "category": "ReadonlyArray<T>",
    "category_en": "ReadonlyArray<T>",
    "explanation": "'ReadonlyArray<T>'는 읽기 전용 배열을 나타냅니다. 이 배열에는 'push', 'pop' 등 배열을 변경하는 메서드가 존재하지 않습니다. 'push'를 호출하려고 했으므로 컴파일 에러가 발생합니다.",
    "explanation_en": "'ReadonlyArray<T>' represents a read-only array. This array type does not have methods that modify the array, such as 'push' or 'pop'. Attempting to call 'push' results in a compile error.",
    "question": "const numbers: ReadonlyArray<number> = [1, 2, 3];\nnumbers.push(4);",
    "answer": false
  },
  {
    "id": 66,
    "difficultyLevel": "INTERMEDIATE",
    "category": "keyof typeof",
    "category_en": "keyof typeof",
    "explanation": "'typeof'는 값의 타입을, 'keyof'는 타입의 키들을 유니언으로 가져옵니다. 'LogLevel'은 Enum 객체이며, 'keyof typeof LogLevel'는 '\"ERROR\" | \"WARN\" | \"INFO\"'가 됩니다. 'levelKey'는 이 타입에 부합합니다.",
    "explanation_en": "'typeof' gets the type of a value, and 'keyof' gets the keys of a type as a union. 'LogLevel' is an enum object, and 'keyof typeof LogLevel' becomes '\"ERROR\" | \"WARN\" | \"INFO\"'. 'levelKey' conforms to this type.",
    "question": "enum LogLevel { ERROR, WARN, INFO }\ntype LogLevelStrings = keyof typeof LogLevel;\nconst levelKey: LogLevelStrings = 'WARN';",
    "answer": true
  },
  {
    "id": 67,
    "difficultyLevel": "INTERMEDIATE",
    "category": "클래스 상속과 메서드 오버라이딩",
    "category_en": "Class Inheritance and Method Overriding",
    "explanation": "자식 클래스는 부모 클래스의 메서드를 오버라이드할 수 있습니다. 'Dog' 클래스는 'Animal'의 'move' 메서드를 올바르게 오버라이드하고 'super.move()'를 호출하여 부모 메서드를 실행했습니다. 에러가 없습니다.",
    "explanation_en": "A child class can override methods of its parent class. The 'Dog' class correctly overrides the 'move' method of 'Animal' and calls the parent method using 'super.move()'. There is no error.",
    "question": "class Animal {\n  move(distance: number = 0) {\n    console.log(`Moved ${distance}m.`);\n  }\n}\nclass Dog extends Animal {\n  move(distance: number = 5) {\n    super.move(distance);\n  }\n}\nconst dog = new Dog();\ndog.move();",
    "answer": true
  },
  {
    "id": 68,
    "difficultyLevel": "INTERMEDIATE",
    "category": "private vs protected",
    "category_en": "private vs protected",
    "explanation": "'protected' 멤버는 해당 클래스와 그 자식 클래스 내에서만 접근 가능합니다. 'Dog' 클래스는 'Animal'을 상속했으므로 'this.name'에 접근할 수 있습니다. 하지만 클래스 외부의 인스턴스에서는 접근할 수 없으므로 'dog.name'은 컴파일 에러를 발생시킵니다.",
    "explanation_en": "'protected' members are accessible only within the class and its subclasses. Since the 'Dog' class inherits from 'Animal', it can access 'this.name'. However, it is not accessible from instances outside the class, so 'dog.name' causes a compile error.",
    "question": "class Animal {\n  protected name: string;\n  constructor(name: string) { this.name = name; }\n}\nclass Dog extends Animal {\n  getName() { return this.name; }\n}\nconst dog = new Dog('Max');\nconsole.log(dog.name);",
    "answer": false
  },
  {
    "id": 69,
    "difficultyLevel": "INTERMEDIATE",
    "category": "옵셔널 체이닝과 함수",
    "category_en": "Optional Chaining with Functions",
    "explanation": "옵셔널 체이닝(?.)은 객체의 프로퍼티가 null 또는 undefined일 때 에러를 발생시키지 않고 undefined를 반환합니다. 'user.sayHi'는 존재하지 않으므로 'user.sayHi?.()'는 에러 없이 undefined를 반환합니다.",
    "explanation_en": "Optional chaining (?.) prevents an error from being thrown when a property of an object is null or undefined, returning undefined instead. Since 'user.sayHi' does not exist, 'user.sayHi?.()' returns undefined without an error.",
    "question": "type User = { name: string, sayHi?: () => void };\nconst user: User = { name: 'Alice' };\nuser.sayHi?.();",
    "answer": true
  },
  {
    "id": 70,
    "difficultyLevel": "EXPERT",
    "category": "조건부 타입과 never",
    "category_en": "Conditional Types with never",
    "explanation": "'IsFunction' 타입은 T가 함수가 아니면 'never'를 반환합니다. 'FunctionKeys'는 'Person' 타입의 프로퍼티 중 함수 타입인 프로퍼티의 키만 남깁니다. 'key' 변수는 '\"sayHello\"' 타입이 되고, 할당된 값과 일치합니다.",
    "explanation_en": "The 'IsFunction' type returns 'never' if T is not a function. 'FunctionKeys' retains only the keys of properties in the 'Person' type that are function types. The 'key' variable becomes of type '\"sayHello\"', matching the assigned value.",
    "question": "type IsFunction<T> = T extends (...args: any[]) => any ? T : never;\ntype FunctionKeys<T> = { [K in keyof T]: IsFunction<T[K]> extends never ? never : K }[keyof T];\n\ninterface Person { name: string; age: number; sayHello(): void; }\ntype PersonFunctionKeys = FunctionKeys<Person>;\n\nconst key: PersonFunctionKeys = 'sayHello';",
    "answer": true
  },
  {
    "id": 71,
    "difficultyLevel": "EXPERT",
    "category": "Awaited<T> 유틸리티 타입",
    "category_en": "Awaited<T> Utility Type",
    "explanation": "'Awaited<T>' 타입은 Promise의 중첩을 재귀적으로 풀어서 최종적으로 resolve되는 값의 타입을 반환합니다. 'DeepPromise'는 'Promise<Promise<string>>'이므로 'Awaited<DeepPromise>'는 'string'이 됩니다. 'result'는 'string' 타입이므로 에러가 없습니다.",
    "explanation_en": "The 'Awaited<T>' type recursively unwraps nested Promises to return the type of the finally resolved value. Since 'DeepPromise' is 'Promise<Promise<string>>', 'Awaited<DeepPromise>' becomes 'string'. The 'result' variable is of type 'string', so there is no error.",
    "question": "type DeepPromise = Promise<Promise<string>>;\ntype Unwrapped = Awaited<DeepPromise>;\n\nconst result: Unwrapped = 'done';",
    "answer": true
  },
  {
    "id": 72,
    "difficultyLevel": "EXPERT",
    "category": "생성자 함수와 InstanceType<T>",
    "category_en": "Constructor Functions and InstanceType<T>",
    "explanation": "'InstanceType<T>'는 생성자 함수의 인스턴스 타입을 추출합니다. 'Car' 클래스의 인스턴스 타입은 '{ drive: () => void; }' 입니다. 'factory' 함수는 이 타입의 인스턴스를 반환해야 하지만, 'drive' 메서드가 없는 객체를 반환하므로 컴파일 에러가 발생합니다.",
    "explanation_en": "'InstanceType<T>' extracts the instance type of a constructor function. The instance type of the 'Car' class is '{ drive: () => void; }'. The 'factory' function should return an instance of this type, but it returns an object without the 'drive' method, causing a compile error.",
    "question": "class Car {\n  drive() { console.log('vroom'); }\n}\n\nfunction factory<T extends new (...args: any[]) => any>(Ctor: T): InstanceType<T> {\n  return new Ctor();\n}\n\nconst myCar = factory(Car);\nmyCar.drive();",
    "answer": true
  },
  {
    "id": 73,
    "difficultyLevel": "EXPERT",
    "category": "고차 함수와 제네릭",
    "category_en": "Higher-Order Functions with Generics",
    "explanation": "'withLogging' 함수는 제네릭을 사용하여 어떤 함수든 받아 로깅 기능을 추가한 새로운 함수를 반환합니다. 타입 추론이 올바르게 이루어져, 'loggedAdd'는 '(a: number, b: number) => number' 타입이 됩니다. 호출 시 타입이 일치합니다.",
    "explanation_en": "The 'withLogging' function uses generics to accept any function and returns a new function with added logging capabilities. Type inference works correctly, making 'loggedAdd' of type '(a: number, b: number) => number'. The types match upon calling.",
    "question": "function withLogging<T extends (...args: any[]) => any>(fn: T): T {\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    console.log(`Calling ${fn.name}`);\n    return fn(...args);\n  }) as T;\n}\n\nconst add = (a: number, b: number) => a + b;\nconst loggedAdd = withLogging(add);\nloggedAdd(2, 3);",
    "answer": true
  },
  {
    "id": 74,
    "difficultyLevel": "EXPERT",
    "category": "공변성과 반공변성 (객체)",
    "category_en": "Covariance and Contravariance (Objects)",
    "explanation": "객체 프로퍼티는 공변적입니다. 더 좁은 타입('Dog')을 프로퍼티로 갖는 객체는 더 넓은 타입('Animal')을 프로퍼티로 갖는 객체가 필요한 곳에 할당될 수 있습니다. 'dogContainer'를 'animalContainer'에 할당하는 것은 유효합니다.",
    "explanation_en": "Object properties are covariant. An object with a narrower type property ('Dog') can be assigned to a place expecting an object with a wider type property ('Animal'). Assigning 'dogContainer' to 'animalContainer' is valid.",
    "question": "class Animal {}\nclass Dog extends Animal {}\n\nlet animalContainer: { value: Animal } = { value: new Animal() };\nlet dogContainer: { value: Dog } = { value: new Dog() };\n\nanimalContainer = dogContainer;",
    "answer": true
  },
  {
    "id": 75,
    "difficultyLevel": "EXPERT",
    "category": "매핑된 타입과 키 필터링",
    "category_en": "Mapped Types with Key Filtering",
    "explanation": "'as' 절과 'never'를 사용하여 매핑된 타입의 키를 필터링할 수 있습니다. 'PublicProps'는 'User'에서 'public' 프로퍼티가 true인 키('name')만 남깁니다. 'publicUser' 객체는 'name' 프로퍼티만 가져야 하지만, 'age'를 포함하고 있어 컴파일 에러가 발생합니다.",
    "explanation_en": "Keys of a mapped type can be filtered using the 'as' clause and 'never'. 'PublicProps' retains only the keys from 'User' where the 'public' property is true ('name'). The 'publicUser' object should only have the 'name' property but includes 'age', causing a compile error.",
    "question": "type User = {\n  name: { value: string; public: true };\n  age: { value: number; public: false };\n}\n\ntype PublicKeys<T> = { [K in keyof T]: T[K] extends { public: true } ? K : never }[keyof T];\ntype PublicProps = Pick<User, PublicKeys<User>>;\n\nconst publicUser: PublicProps = { name: { value: 'John', public: true }, age: { value: 30, public: false } };",
    "answer": false
  },
  {
    "id": 76,
    "difficultyLevel": "EXPERT",
    "category": "매핑된 타입과 `keyof`",
    "category_en": "Mapped Types and `keyof`",
    "explanation": "이 코드는 객체의 각 값에 대한 타입을 해당 키의 리터럴 타입으로 변환하는 `KeyMirror` 타입을 정의합니다. `ActionTypes`는 `{ login: \"login\"; logout: \"logout\"; }` 타입이 됩니다. `action` 변수의 타입은 이 구조에 부합합니다.",
    "explanation_en": "This code defines a `KeyMirror` type that transforms the type of each value in an object to the literal type of its key. `ActionTypes` becomes the type `{ login: \"login\"; logout: \"logout\"; }`. The type of the `action` variable conforms to this structure.",
    "question": "type KeyMirror<T extends object> = { [K in keyof T]: K };\n\nconst actions = { login: null, logout: null };\ntype ActionTypes = KeyMirror<typeof actions>;\n\nconst action: ActionTypes = {\n  login: 'login',\n  logout: 'logout'\n};",
    "answer": true
  },
  {
    "id": 77,
    "difficultyLevel": "EXPERT",
    "category": "infer와 재귀 타입",
    "category_en": "infer with Recursive Types",
    "explanation": "'Flatten' 타입은 재귀적으로 배열의 중첩을 한 단계씩 풀어냅니다. `number[][][]` 타입에 적용하면 `number[][]`가 됩니다. `flat1`은 이 타입에 부합합니다.",
    "explanation_en": "The 'Flatten' type recursively unwraps one level of array nesting. When applied to `number[][][]`, it becomes `number[][]`. `flat1` conforms to this type.",
    "question": "type Flatten<T> = T extends (infer U)[] ? U : T;\n\ntype N3 = number[][][];\ntype N2 = Flatten<N3>;\n\nconst flat1: N2 = [[1], [2]];",
    "answer": true
  },
  {
    "id": 78,
    "difficultyLevel": "EXPERT",
    "category": "유니언 타입 분배 방지",
    "category_en": "Preventing Union Distribution",
    "explanation": "조건부 타입에서 제네릭 타입을 `[T]`와 같이 튜플로 감싸면 유니언 타입의 분배적 동작을 막을 수 있습니다. `[T] extends [any]`는 항상 참이므로 `ToArrayNonDist<string | number>`는 `(string | number)[]`가 됩니다. `arr`는 이 타입에 부합합니다.",
    "explanation_en": "Wrapping a generic type in a tuple, like `[T]`, within a conditional type prevents the distributive behavior of union types. `[T] extends [any]` is always true, so `ToArrayNonDist<string | number>` becomes `(string | number)[]`. The `arr` variable conforms to this type.",
    "question": "type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;\n\ntype StrOrNumArray = ToArrayNonDist<string | number>;\n\nconst arr: StrOrNumArray = ['hello', 1];",
    "answer": true
  },
  {
    "id": 79,
    "difficultyLevel": "EXPERT",
    "category": "데코레이터 (실험적 기능)",
    "category_en": "Decorators (Experimental)",
    "explanation": "데코레이터는 클래스, 메서드, 프로퍼티 등에 부가적인 기능을 연결하는 실험적인 기능입니다. 'sealed' 데코레이터는 클래스 생성자와 프로토타입을 동결시킵니다. 코드는 데코레이터의 유효한 사용 예시입니다.",
    "explanation_en": "Decorators are an experimental feature for attaching additional functionality to classes, methods, and properties. The 'sealed' decorator freezes the class constructor and its prototype. The code is a valid example of decorator usage.",
    "question": "function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n\n@sealed\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n}",
    "answer": true
  }
]
